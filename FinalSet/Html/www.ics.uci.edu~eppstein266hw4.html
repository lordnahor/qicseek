<HTML><HEAD>
<TITLE>Computational Geometry</TITLE>
<META name="Owner" value="eppstein">
<META name="Reply-To" value="eppstein@ics.uci.edu">
</HEAD><BODY>
<H1>ICS 266, Spring 1996, Homework Set 4</H1>
<H2>Due Thursday, May 30, in class</H2>

<HR><P>

<OL>
<LI><B>Incremental and randomized incremental algorithms</B>.
A <I>trapezoidal decomposition</I> of a polygon
is formed by drawing a vertical line segment up and down through each vertex
of the polygon, extending until it reaches the polygon boundary.
The trapezoidal decomposition of a line arrangement
is formed by performing this process in each cell of the arrangement.
<P>
<UL>
<LI>
Show how to modify the incremental line arrangement algorithm we
discussed in class
to compute trapezoidal decompositions, in the same overall O(n^2) time bound.
<P>
<LI>
Show how to use a <I>history graph</I> of these trapezoids,
in which we store (for each trapezoid formed at any stage of the algorithm)
a description of the event causing the trapezoid to stop being part of
the decomposition, to perform point location queries in this decomposition.
What types of events can occur?  How much space does the data structure use?
What is the worst case query time of
your data structure?
<P>
<LI>
Show that if the lines are added in random order,
the history graph can be used to perform point location queries
in O(log n) expected time.
<P>
<LI>
What goes wrong if we try to simplify this point location data structure,
by using cells in the arrangement rather than trapezoids of the
decomposition, and storing (for each cell formed at any stage of the
algorithm) a pointer to the first line cutting it and the two cells it
is cut into?
</UL>
<P>

<LI><B>Linear programming and LP-type problems</B>.
<P>
Recall that an <I>LP-type</I> problem is defined by a set S
and a function f mapping subsets of S to some totally ordered space,
satisfying the following two properties:
<UL>
<LI>If A is a subset of B, then f(A) &lt;= f(B).
<LI>If f(A)=f(A u {x})=f(A u {y}), then f(A)=f(A u {x,y}).
</UL>
<P>
A <I>basis</I> of the problem is a set B such that
for any proper subset A, f(A) &lt; f(B).
The <I>dimension</I> of the problem is the size of the largest basis.
The answer to a problem consists of the value of f(S),
or equivalently max_B f(B) where the maximization occurs over all bases. 
In class we saw randomized algorithms for solving such problems
using a number of basis evaluations linear in |S| and exponential
in the dimension.
<P>
<UL>
<LI>Suppose we have two sets of points S and T in three-dimensional space,
and we wish to determine whether some plane separates S from T.
Can you express this as an LP-type problem?  As a low dimensional linear
program?  (<I>Hint</I>: use projective duality.)
<P>
<LI>Suppose we have solved the first part, and know that a plane
separates S from T; then their convex hulls must be disjoint.
Show how to express the problem of finding the closest pair of points x
and y, with x in the convex hull of S and y in the convex hull of T,
as an LP-type problem.  What is its dimension?
(<I>Note</I>: x and y might not be part of the input sets S and T,
they can be any points contained in the respective convex hulls.  You
can assume that the points are in general position e.g. no two faces of
the convex hulls are parallel.)
<P>
<LI>The problem of
finding the closest pair s in S and t in T is not LP-type, even if you
know that the convex hulls of S and T are disjoint.
Which property defining LP-type problems is violated?
</UL>
<P>

<LI><B>Dynamic programming</B>.<BR>
<I>[Corman, Leiserson, and Rivest,
"Introduction to Algorithms", problem 16-1, p. 324.]</I>
<P>
The <I>Euclidean traveling-salesman problem</I> is the problem of
determining the shortest closed tour that connects a given set of
<I>n</I> points in the plane.  The general problem is NP-complete.  J.
L. Bentley has suggested the problem by restricting our attention to
<I>bitonic tours</I>, that is, tours that start at the leftmost point,
go strictly left to right to the rightmost point, and then go strictly
right to left back to the starting point.  (Equivalently, any vertical
line should cross the tour at most twice.)
<P>
Describe an <I>O(n^2)</I>-time algorithm for determining an optimal
bitonic tour.  You may assume that no two points have the same
<I>x</I>-coordinate.  (<I>Hint</I>: Scan left to right, maintaining
optimal possibilities for the two parts of the tour.)
</OL>

<HR><P>
<A HREF="/~eppstein/266/">ICS 266</A>,
<A HREF="/~eppstein/">David Eppstein</A>,
<A HREF="/">Dept. Information & Computer Science</A>,
<A HREF="http://www.uci.edu/">UC Irvine</A><BR>
<SMALL>Last update: 21 May 1996, 10:56:45 PDT</SMALL>
</BODY></HTML>

