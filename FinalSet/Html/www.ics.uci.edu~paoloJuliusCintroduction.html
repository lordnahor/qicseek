<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
	<meta HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
        <link REL="icon" HREF="minilogo.png" TYPE="image/png">
	<title> JuliusC: Introduction </title>
	<meta NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
	<meta NAME="CREATED" CONTENT="20030530;9241400">
	<meta NAME="CHANGED" CONTENT="20030530;9423600">
	<meta NAME="person" CONTENT="Paolo">

	<meta NAME="sortname" CONTENT="D'Alberto Paolo">
	<!-- Background black, links yellow (unvisited), blue (visited), red (active) -->
	<style>
	
	</STYLE>
</head>
<body LANG="en-US" TEXT="#000000" LINK="#ff0000" VLINK="#00ff00"  background="DAG.3.jpg">
<h1 ALIGN=CENTER>  Introduction </h1>

<ol>
<HR>
  
  <li><h3 ALIGN=LEFT> Romans' Divide et Impera vs. Computer Science's
  Divide and Conquer.</h3>


    
  <P> Romans <i>divided</i> their enemy by fomenting internal fights
  within the enemy groups (e.g., ethnic groups). When the enemy was
  exhausted by the internal turmoils, either the Romans attacked and
  destroyed the enemy's weak defenses or, more often, they engaged in
  the dispute as peace maker. In this way, the Romans could lead their
  own legions among enemy lines so to control the territory and the
  enemy animosities. </P>

  <P> Most importantly, peace was so desperately needed that the
  Romans were often welcome, even as rulers, and they did not need to
  engage in any <i>real</i> battle; they needed mostly to control, to
  protect and to build. </P>

  <P> We may say that the divide et impera worked like magic, avoiding
  the battle and therefore the loss of personnel and legionaires.
  </P>

  <P> In computer science, we are familiar with the definition of
  divide and conquer algorithms (e.g., bitonic sort, quick sort,
  matrix multiply).  In a divide and conquer algorithm, A large
  problem is divided into a determined number of small, and more
  manageable, sub-problems. If the sub-problem size is small enough
  that we can solve it with the given resources, we just solve it;
  otherwise, we divide it in smaller problems. When each sub problem
  is solved, the solutions are combined to achieve the final solution.
  </P>

  <P> Here, we are bound to solve each small problem; in other words,
  we have to work solving the small sub-problems.
  </P>
  <ul>
  <li> <P> The complexity of a divide and conquer algorithm is based on the
  contribution of two factors:</P>

  <ul>
  <li> The type of the division: the number and the size of the
  sub-problems determine how many <i>small</i> problems we have to
  solve. For example, a problem of size <i>n</i> can be decomposed in
  8 sub-problems of size <i>n/2</i> each.
  </li>
  
  <li> The complexity of the solution for a <i>small</i> sub-problem,
  for which we use the term <b>leaf</b>. For example, a problem of
  size  <i>k</i> can have complexity <i>O(ck^3)</i> where <i>c</i> is a
  proper constant.
  </li>
  </ul>
  <P>
  For example, the overall complexity is <i>O(cn^3)</i> (notice that
  this is the complexity for the classic matrix-multiplication
  recursive algorithm). </P>

  </li>
  </ul>

  This project proposes a novel approach in modeling the art of the
  <i>divide</i>, so that a compiler can have a tool in optimizing
  recursive divide and conquer algorithms.

<HR>

  </li>
</ol>

</body>
</html>

