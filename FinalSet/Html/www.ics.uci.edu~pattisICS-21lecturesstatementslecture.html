<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Statements</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Statements</h1>
<p>
<h2>Introduction to Computer Science I-III<br>
ICS-21/-22/-23
<br>
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
  Statements are like complete imperative sentences in Java: each commands
    Java to perform some action.
  Just as we said that Java evaluates expressions, we say that Java executes
    statements.
  We already have studied the Java declaration statement, which declares
    variables (and optionally initializes them).
  We will classify many statements as control structures: such statements
    control (conditionally/by repetition) the execution of other statements.
  <p>
  In this lecture we will first learn how to write the simplest kind of
    statement in Java, the expression statement, and the simplest control
    structure in Java, the block statement,
  We will also begin discussing two analysis tools: hand simulation via trace
    tables, and statement boxing (which is the statement equivalent of oval
      diagrams for expressions). 
  <p>
  Then we will learn about Java's most important control structures,
    starting with <b>if</b> statements for decisions and simple
    <b>for</b>/<b>break</b> statements for looping.
  We will extend our analysis tools, trace tables and boxing, to cover these
    statements.
  Eventually we will generalize the <b>for</b> loop and cover two variants
    of looping: <b>while</b> and <b>do</b> statements.
  <p>
  Finally, we will begin learning about Java's <b>try-catch</b> statement:
    a control structure that programmers use to process exceptions.
  Sometimes when an operator or method fails by throwing an exception, it
    does not denote a failure of the program, but is just a signal to the
    program that it must take some special action.
  We will continue exploring the use of the <b>try-catch</b> statement in
    our next lecture, in the context of file I/O.
  <p>
  Thus, we can summarize the language features that we learn in this lecture by<p>
  &nbsp &nbsp <i>statement</i> <=
       <i>local-declaration-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>expression-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>block-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>if-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>for-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>break-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>while-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>do-statement</i> |
<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>try-catch--statement</i>
<p>
  We will explore the semantics of the following control structures in detail.
  <ul>
    <li>block: execute a sequence of statements in order
    <li>if: decide which statement to execute
    <li>for/while/do loop: repeatedly execute a statement
    <li>break: terminate execution of a loop
    <li>try-catch: execute a sequence of statements; if one throws an
         exception, execute an alternative sequence of statements
  </ul>
</td>
</tbody>
</table>


<!-- Declaring Variables -->

<a name="Declarations">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Declaring Variables<br>(review and extension)</b></td>
<td width ="80%">
  We have already discussed most aspects of the
  <a href="../voe/lecture.html#Declarations">
    <i>declaration-statement</i></a>
  in depth.
  Recall that the simplest declarations start with the type of the variable,
    followed by the name of the variable, ended by a semicolon.
  In more complex variable declarations, we can specify multiple variable
    names (each declared to be the same type, the one that starts the
    declaration), and each variable can be initialized to a value.
  <p>
  We originally specified the EBNF for each declarator as
  <p>
<i>&nbsp &nbsp variable-declarator</i> <= <i>identifier</i> [=<i>expression</i>]  <p>
    and said that <i>expression</i> could be only a literal (the only kind of
    expression we knew at that time).
  Now we know about much more complicated expressions, including literals,
    variables, operators, and methods; we can use all these to declare the
    initial values for variables.
  Pragmatically, most intializations use either literals or calls to the
    <b>Prompt</b> methods, but other form arise less frequently.
  Here are some examples.
<pre><b>  int a = 0;
  int b = Prompt.forInt("Enter b");
  int c = b;
  int d = Math.max(c,1) + 1;</b></pre>
  <p>
  Here the declation of <b>a</b> is intialized using the literal <b>0</b>;
    the declation of <b>b</b> is initialized to the result returned by calling
      the <b>Prompt.forInt</b> method;
    the declation of <b>c</b> is initialized using <b>b</b>, the value of a
      previous declared and intialized variable;
    finally, the declation of <b>d</b> is initialized to the result returned
      by an expression involving a method call, operator, literal, and
      the value of a previously declared variable (<b>c</b>).
  <p>
  In addition, Java allows the keyword <b>final</b> to appear optionally in
   <p>
&nbsp &nbsp <i>local-variable-declaration-statement</i> <= [<b>final</b>] <i>type</i> <i>variable-declarators</i> ;<p> 
  Semantically, if such a declaration includes <b>final</b>, then all the
    variables that it declares must include an initializer and the value they
    store must never be changed.
  That is, we cannot use any state-change operators on <b>final</b> variables.
  If we declared
<b><pre>  final double PI = 3.14159265358979323846;</pre></b>
  Then Java would detect and report an error if we later wrote <b>PI = 3.0</b>
  Thus, we can use <b>final</b> to declare named constants, whose value is
    guaranteed by Java not to change.
</td>
</tbody>
</table>



<!-- Expression Statements -->

<a name="ExpressionStatements"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Expression Statements</b></td>
<td width ="80%">
  We can make an <i>expression</i> into <i>expression statement</i> by
    appending a semicolon at its end.
  Such a statement tells Java to evaluate the expression.
  The EBNF rule for expression statements is simply
  <p>
  <i>expression-statement</i> <= [<i>expression</i>] ;<br> 
  <p>
  In fact, by discarding the option, we can write just the semicolon as the
    simplest kind of expression statement: it is a statement that
    "does nothing".
  <p>
  But Java imposes one important syntax constraint on expression statements:
    if the <i>expression</i> option is included
  <ul>
    <li>The <i>expression</i> must apply a state-change operator or a method
          call last in the expression.
  </ul>
  Thus, the following statements are all legal examples of expression
    statements: each satisfies this syntax constraint..
  <pre><b>    average = (score1 + score2 + score3) / 3;
    gameCount++;
    counter1 = counter2 = counter3 = 0;
    System.out.println("You have played "+gameCount+" games");</b></pre>
  Recall that most state-change operators have very low precedence, so they
    will naturally be evaluated last in an expression statement.
  Methods whose prototype lists <b>void</b> as the type of the result don't
    return a result anyway.
  Such methods (e.g., <b>System.out.println</b>) are often called last when
    evaluating expression statements.
  <p>
  Note that <b>x+1;</b> is NOT a legal expression statement: the last operator
    that it applies is <b>+</b>, which computes a value but does not process
    this value further: e.g., doesn't store it anywhere; doesn't print it.
  Writing such an expression serves no purpose, and the Java compiler detects
    and reports an error in this case.
  <p>
  Finally, notice that this syntax constraint still allows
    <b>Prompt.forInt("Enter values");</b> as a legal expression statement,
    even though this method returns an <b>int</b> result which is not processed
    further.
</td>
</tbody>
</table>



<!-- Blocks -->

<a name="Blocks"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Block Statements<br>(and scope)</b></td>
<td width ="80%">
  Some airlines restrict you to one carry-on bag.
  If you show up with three small bags, they won't let you on the plane; but
    if you buy a fourth, big bag, and put your original three into the
    fourth, everything will be fine.
  <p>
  Java's syntax sometimes forces this same kind of behavior.
  There are places (mostly inside the control structures we will study later
    in this reading) where only one statement is allowed; if you want multiple
    statements there, you must put them inside one big statement.
  That single, big statement is called a <i>block-statement</i>,
    of sometimes just a <b>block</b>.
  The EBNF rule for blocks is 
  <p>
  <i>block-statement</i> <= {{<i>statement</i>}}<br> 
  <p>
  In this EBNF rule, the outer braces stand for themselves, the inner ones mean
     repetition.
  That is, blocks are some number of statements enclosed in braces.
  So, a block itself is a statement, inside which we can put other statements.
  Although we write this EBNF rule on one line, <b>block</b> statements in our
    code often span many lines, with each statement inside the block appearing
    on its own line, indented in the braces.
  <p>
  Semantically, Java executes a block by sequentially executing the statements 
    that it contains (in the exact same order that they appear in the block).
  When giving directions to humans or computers, often the order in which the
    directions are followed is critical.
  If the directions say, "To disarm the bomb, cut the blue wire and then cut
    the red wire" it would not be a good idea for us to change the order in
    which these wires are cut.
  <p>
  
  If a statement inside a block declares a variable, that variable can be used
    in <i>subsequent</i> statements <i>inside</i> that block; after Java
    executes all the statements in a block, the block is finished executing,
    and ALL variables declared inside the block become undeclared.
  So, such variables are called <b>local variables</b> because they exist only 
    locally, inside the block, while its statements are executing.
  <p>
  Technically, we call all those places that a variable can be used the
    <b>scope</b> of that variable.
  So the scope of local declarations in blocks include all subsequence
    statements in that block.
  <p>
  Blocks themselves can be nested.
  Any variables declared in an outer block can be used in an inner block.
  For example
<pre><b>{ //Outer block
  int x = 1;
  { //Inner block
    System.out.println(x);     //Refers to x in outer block
    x = 3;                     //Refers to x in outer block
  }
  System.out.println(x);
}</b></pre>
  This example illustrates that the scope of the variable <b>x</b> includes the
    whole outer-block, which includes its inner block too.
  The inner block is just one statement that is included in the outer block
    (which is itself one bigger statement).
  In this example, Java prints <b>1</b> followed by <b>3</b>.
  <p>
  If we had moved the declaration from the outer block to the start of the
    inner block, Java would detect and report an error at compile time.
<pre><b>{ //Outer block
  { //Inner block
    int x = 1;
    System.out.println(x);     //Refers to x in inner block
    x = 3;                     //Refers to x in inner block
  }
  System.out.println(x);       //Error! the x in the inner block
                               // is undeclared for this statement.
}</b></pre>
  With this placement, the variable <b>x</b> would not be accessible outside
    the inner block, so it would be unknown in the final print method.
  The scope of <b>x</b> is just the inner block in which it is declared.
</td>
</tbody>
</table>
</td>
</tbody>
</table>


<!-- A Block of COde-->

<a name="ABlock"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Putting Everything Together</b></td>
<td width ="80%">
  Finally, putting together everything that we have learned about Java, the
    following block contains a variety of statements that perform a simple
    computation: declaring variables, prompting the user for values to store
    in these variables (by calling a method), performing a simple calculation
    with these variables (storing the result in another variable with a state
    change operator) and displaying the result in the console window.<pre><b>{        
  double gravity;           //meter/sec/sec
  double height;            //meters
  double time;              //sec
		  
  //Input
  gravity = Prompt.forDouble("Enter gravity (in m/s/s)");
  height  = Prompt.forDouble("Enter height of drop (in m)");
		  
  //Calculate
  time = Math.sqrt(2.*height/gravity);
		  
  //Output
  System.out.println();
  System.out.println("Drop time = " + time + " secs");
}</pre></b>
  Note that by intializing variables when they are declared, we could
   "simplify" this code, writing it as follows.
  Both blocks ultimate produce the same results.
<pre><b>{  
  //Input      
  double gravity = Prompt.forDouble("Enter gravity (in m/s/s)");
  double height  = Prompt.forDouble("Enter height of drop (in m)");

  //Calculate	  
  double time = Math.sqrt(2.*height/gravity);
		  
  //Output
  System.out.println();
  System.out.println("Drop time = " + time + " secs");
}</pre></b>
  In fact, there is no need in this program for variables at all!
  We can squeeze this entire program down to just one statement, using the
    <b>\n</b> escape sequence inside one huge (4 line) output statement.
<pre><b>{  
  System.out.println("\nDrop time = " + 
      Math.sqrt(2.*Prompt.forDouble("Enter height of drop (in m)")
                /Prompt.forDouble("Enter gravity (in m/s/s)")) +
      " secs");
}</pre></b>
  Although this program is the smallest yet, it is a bit complicated to follow
    the calculation, which includes two prompts to the user as part of the
    formula being computed.
  Thus, while smaller is generally better, it isn't here; sometimes storing
    partial calculations in nicely named variables helps us to write clearer,
    easier to understand programs (a main goal of ICS-21).
  Of course, if the program needs to use the values entered by the user more
    than once, we should store them in variables to avoid reprompting the user
    for the same information multiple times.
</td>
</tbody>
</table>



<!-- Hand Simulation -->

<a name="HandSimulation"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Hand Simulating State Changes</b></td>
<td width ="80%">
  As programmers, we must be able to analyze our programs to verify that they
    are correct, or detect where bugs occur (the hard part) and fix them (an
    easier part).
  The most important way to analyze code is to be able to <i>hand simulate</i>
    it.
  The "input" to a hand simulation is
  <ul>
    <li>Variables and their current values (called the initial state)
    <li>A block of code (a sequence of statements)
    <li>If needed, values that the user enters to prompts on the console
  </ul>
  The "output" to a hand simulation is
  <ul>
    <li>The same variables and their resulting values, and the contents of the
          console (called the final state)
  </ul>
  During a hand simulation we construct a <i>trace table</i> of state-changes
    for each statement executed in the block of code; these include changes to
    the states of variables and changes to the state of the console (what
    input/output the program does).
  <p>
  Here is a simple example (no input/output) of such a trace table.
  Assume <b>int x=5; int y=8;</b> and the block <b>{x=y; y=x;}</b>
  If beginning students are asked to predict what the code does, the most
    common response is that it swaps the values in <b>x</b> and <b>y</b>.
  Let's see what really happens using a trace table (note that a table cell
    shows the value stored in a variable <i>after</i> the statement on its
    line is finished).
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>x</th><th>y</th><th>Console</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial States</td><td>5</td><td>8</td><td>&nbsp</td>
  <tr valign="top"><td>x=y;</td><td>8</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>y=x;</td><td>&nbsp</td><td>8</td><td>&nbsp</td>
  </tbody>
  </table>
  <p>
  So, we see that the values in the variables are not swapped, but
    that <b>y</b>'s initial value ends up stored in both <b>x</b> and <b>y</b>.
  In some sense, the simplest thing to do with two variables is to exchange
    their values; yet the intuitive way to write code for this task is
    incorrect.
  Don't gloss over this observation, because it is very important.
  The kind of reasoning a programmer does about state changes in code is very
    different from the kind of reasoning a mathematician does about equations.
  <p>
  One correct way to swap the values stored in two variables is:
    <b>{int temp=x; x=y; y=temp;}</b>, and the hand simulation illustrating
    its correctness (using the same initial state).
  <p>  
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>x</th><th>y</th><th>temp</th><th>Console</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial States</td><td>5</td><td>8</td><td>Undeclared</td><td>&nbsp</td>
  <tr valign="top"><td>int temp=x;</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td>
  <tr valign="top"><td>x=y;</td><td>8</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>y=temp;</td><td>&nbsp</td><td>5</td><td>Undeclared</td><td>&nbsp</td>
  </tbody>
  </table>
  <p>
  Note how <b>temp</b> is shown as undeclared before the block is executed and
    also becomes undeclared  after Java finishes executing the block.
  But <b>temp</b> plays a crucial part in the computation, while Java is
    executing the statements in the block that it is declared in.
  <p>
  As a final example, let's examine the trace table for a block that does
    I/O too.
  Here there are no variables in the initial state: the block to execute is:
    <b><pre>    {
      double x,y;
      x = Prompt.forDouble("Enter x");
      y = Math.pow(x,3.);
      System.out.println(x + " cubed = " + y);
    }</pre></b>
  Finally, when prompted, the user will enter a 5.1 on the console.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>x</th><th>y</th><th>Console</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial States</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td>
  <tr valign="top"><td>double x,y;</td><td>?</td><td>?</td><td>&nbsp</td>
  <tr valign="top"><td>x = Prompt.forDouble("Enter x");</td><td>5.1</td><td>&nbsp</td><td>Enter x: 5.1</td>
  <tr valign="top"><td>y = Math.pow(x,3.);</td><td>&nbsp</td><td>132.651</td><td>&nbsp</td>
  <tr valign="top"><td>System.out.println(x + " cubed = " + y);</td><td>Undeclared</td><td>Undeclared</td><td>5.1 cubed = 132.651</td>
  </tbody>
  </table>
  <p>
  Here the <b>Console</b> column shows what is on each line (on the first
    line, the prompt and the value that the user enters; on the second line
    the answer).
  This is certainly a lot of work for such a simple example; but if you can
    easily write such trace tables, you can use them to debug code that has
    much subtler errors.
</td>
</tbody>
</table>



<!-- Boxing Simple Statements -->

<a name="Boxing1">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Boxing Statements</b></td>
<td width ="80%">
  Just as we used oval diagrams to understand the structure of expressions
   (and their subexpressions), we will use box diagrams to understand
    statements (and in the case of control structures, their substatements).
  <p>
  Right now we know three kinds of statements: declaration statements,
    expression statements, and block statements.
  Declaration statements and expression statements contain never contain
    substatements; block statements contain substatements: the statements
    that the block executed sequentially.
  The example below includes multiple occurences of each of these kinds of
    statements.
  Each statement appears inside a box.
</td>
</tbody>
</table>
<img src="images/boxed1.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  Practice the skill of boxing statements.
  Learn to "see" statements inside of statements, the way a programmer does.
  Notice how consistent indenting in the code makes this task easier.
</td>
</tbody>
</table>



<!-- If Statements -->

<a name="IfStatements"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>if Statements</b></td>
<td width ="80%">
  In Java, <b>if</b> statements allow us to choose whether or not to execute
  another statement, or which one of many statements to execute
  (like both the option and alternative forms in EBNF).
<p>
  There are three forms of <b>if</b> statements in Java.
  <ul>
    <li><b>if</b>
    <li><b>if/else</b>
    <li><b>cascaded if</b> or <b>cascaded if/else</b>
  </ul>
  The general form of all <b>if</b> statements is given by one EBNF rule
  <p>
  <i>if-statement</i> <= <b>if (</b><i>expression</i></b>)</b> <i>statement</i> [<b>else</b> <i>statement</i>]
  <p>
  As a syntax constraint, <i>expression</i> must result in a <b>boolean</b>
    value (if it doesn't, the Java compiler detects and reports this error).
  Note that both <b>if</b> and <b>else</b> are keywords in Java, and the test
    expression, no matter how simple or complicated, must always appear inside
    parentheses.
  Finally, although we write this EBNF rule on one line, we write <b>if</b>
    statements in code that span at least two (and often many more) lines, and
    contain indented statements.
  <p>
  An <b>if</b> statement (discarding the option) decides whether or not to
    execute its statement.
  We write it as<pre><b>   if (test)
     statement</b></pre>
  Recall that <b>statement</b> can also be a block.
  Two <b>if</b> statement examples are  <pre><b>   if (x < 0)
     x = -x;


   if (myNumber == rouletteNumber) {
     myWins++;
     myPurse += stakes;
   }</b></pre>
   Notice where the opening and closing brace appear for this block: this is
     the standard style that we will always use for blocks inside <b>if</b>
      statements.
   <p>
   Semantically, Java executes an <b>if</b> statement as follows
   <ul>
     <li>Evaluate the <b>test</b> expression.
     <li>If it is <b>true</b>, execute the (single) statement after the <b>test</b>.
     <li>If it is <b>false</b>, skip the (single) statement after the <b>test</b>.
   </ul>
  So, if the test evaluates to <b>true</b> in the second example, Java executes
    the block statement; it executes the block by sequentially executing the
    two expression statements that it contains.
  If the test evaluates to <b>false</b> in the second example, Java skips the
    block statement (executing neither of the statements that it contains).
  <p>
  An <b>if/else</b> statement (including the option) decides which one of its
    two statements to execute.
  We write it as<pre><b>   if (test)
     statement<sub>1</sub>
   else
     statement<sub>2</sub></b></pre>
  Recall that <b>statement<sub>1</sub></b> and/or <b>statement<sub>2</sub></b>
    can also be a block
  Two example <b>if/else</b> statements are  <pre><b>
   if (x%2 == 0)     //is x is even?
     x = x/2;
   else
     x = 3*x+1;

   if (x > y) {
      min = y;
      max = x;
   }else{
      min = x;
      max = y;
   }</pre></b>
   Semantically, Java executes an <b>if/else</b> statement as follows
   <ul>
     <li>Evaluate the <b>test</b> expression.
     <li>If it is <b>true</b>, execute <b>statement<sub>1</sub></b>, which
           appears directly after the <b>test</b>, then skip
           <b>statement<sub>2</sub></b>.
     <li>If it is <b>false</b>, skip <b>statement<sub>1</sub></b>, then execute
           <b>statement<sub>2</sub></b>, which appears directly after the
           keyword <b>else</b>.
   </ul>
   So in <b>if/else</b> statements, Java always executes one of the two
     substatements that it controls.
   This is a bit different from the plain <b>if</b> statement, which decides
     whether or not to execute the one statement that it controls.
  <p>
  A <b>cascaded if</b> (or <b>cascaded if/else</b>) decides which one (if any)
    of many statements to execute.
  The general form of the <b>cascade if</b> in Java is<pre><b>   if (test<sub>1</sub>)
     statement<sub>1</sub>
   else if (test<sub>2</sub>)
     statement<sub>2</sub>
   else if (test<sub>3</sub>)
     statement<sub>3</sub>
   else ...
     ...
   else if (test<sub>N</sub>)
     statement<sub>N</sub>

   <i>or </i>

   if (test<sub>1</sub>)
     statement<sub>1</sub>
   else if (test<sub>2</sub>)
     statement<sub>2</sub>
   else if (test<sub>3</sub>)
     statement<sub>3</sub>
   else ...
     ...
   else if (test<sub>N</sub>)
     statement<sub>N</sub>
   else
     statement<sub>N+1</sub>
  </b></pre>
  A <b>cascaded if</b> is built from many <b>if/else</b> statements, where
    each of statements in the <b>else</b> part is another <b>if/else</b>
    statement (except possibly the lst one).
  An example <b>cascaded if</b> statement, assuming the declaration
    <b>char grade;</b> is  <pre><b>   if (testScore >= 90)
     grade = 'A';
   else if (testScore >= 80)
     grade = 'B';
   else if (testScore >= 70)
     grade = 'C';
   else if (testScore >= 60)
     grade = 'D';
   else
     grade = 'F';</pre></b>
   Semantically, Java executes a <b>cascaded if</b> statement as follows
   <ul>
     <li>Evaluate the first <b>test</b> expression.
     <li>If it is <b>true</b>, execute the statement after the <b>test</b>
           and terminate the <b>cascaded if</b> (don't check any more tests
           or execute any more statements).
     <li>If it is <b>false</b>, evaluate the second <b>test</b> expression.
     <li>If it is <b>true</b>, execute the statement after the <b>test</b> and
           terminate the <b>cascaded if</b> (don't check any more tests
           or execute any more statements).
     <li>Continue following rules of this form until a <b>true</b> test is
           found, or the last test is evaluated.
     <li>If the last test is <b>true</b>, execute the statement after the                  <b>test</b> and terminate the <b>cascaded if</b> (there are no more
           tests to check).
     <li>If the last test is <b>false</b>, and it is an <b>if</b> statement,
           terminate the <b>cascaded if</b>; if it is an <b>if/else</b>
           statement, execute the statement after the <b>else</b> keyword.
   </ul>
   So in the <b>cascaded if</b>, exactly <b>one</b> statement -the one after
     after the first <b>true</b> test is executed; if no tests are
     <b>true</b>, either no statements are executed (when the last statement 
     is an <b>if</b>) or the statement after the last <b>else</b> is executed.
   Graphically, we can summarize the control flow in the three kinds of
      <b>if</b>s as
   <p>
</td>
</tbody>
</table>
<img src="images/ifcontrol.gif"></image><p>


<!-- Hand Simulations -->

<a name="HandSimulations"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Hand Simulating if statements</b></td>
<td width ="80%">
  We can extend our use of trace tables to hand simulations of <b>if</b>
     statements.
  We include a special <b>Explanation</b> column to indicate the result of
    evaluating <b>test</b> and which statement Java executes next.
  Let's write two trace tables for hand simulating the first <b>if</b>
    statement shown above.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>x</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>-5</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>if (x < 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>
  <tr valign="top"><td>x = -x;</td><td>5</td><td>&nbsp</td><td><b>if</b> finished</td>
  </tbody>
  </table>
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>x</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>5</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>if (x < 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: skip next statement; <b>if</b> finished</td>
  </tbody>
  </table>
  <p>
  Next, let's write two trace tables for hand simulating the second
    <b>if/else</b> statement shown above.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>x</th><th>y</th><th>min</th><th>max</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>5</td><td>3</td><td>?</td><td>?</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>if (x > y)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>
  <tr valign="top"><td>min = y;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>1st statement in block</td>
  <tr valign="top"><td>max = x;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>2nd statement in block; block and <b>if</b> finished</td>
  </tbody>
  </table>
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>x</th><th>y</th><th>min</th><th>max</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>3</td><td>5</td><td>?</td><td>?</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>if (x > y)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute statement after <b>else</b></td>
  <tr valign="top"><td>min = x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>1st statement in block</td>
  <tr valign="top"><td>max = y;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>2nd statement in block; block and <b>if</b> finished</td>
  </tbody>
  </table>
  <p>
  What is the trace table for this example if the values stored in <b>x</b> and
    <b>y</b> are equal?
  Does it produce the correct result?
  Can you change the test to &gt= and still always get the same result?
  Can there be two different ways of getting the same result?
  <p>
  Finally, let's write a trace table for hand simulating the
     <b>cascaded if</b> statement shown above.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>testScore</th><th>grade</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>73</td><td>?</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>if (testScore >= 90)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute <b>if</b> in <b>else</b></td>
  <tr valign="top"><td>if (testScore >= 80)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute <b>if</b> in <b>else</b></td>
  <tr valign="top"><td>if (testScore >= 70)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>
  <tr valign="top"><td>grade = 'C';</td><td>&nbsp</td><td>'C'</td><td>&nbsp</td><td><b>cascaded if</b> finished</td>
  </tbody>
  </table>
</td>
</tbody>
</table>



<!-- A Clock Example-->

<a name="AClockExample"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>A Clock Example</b></td>
<td width ="80%">
  Let's take a quick look at an interesting task that combines all the
    statements that we have studied.
  Assume that we have declared the following variables for a "military" style
    clock: e.g., 00:00 represents midnight, 9:03 represents 9:03am, 14:23
    represents 2:23 pm, and  23:59 represents 11:59pm.
<b><pre>    int minute; //in the range [0,59] inclusive
    int hour;   //in the range [0..23] inclusive</pre></b>
  Also assume that the method <b>emitBeeps</b> takes a single <b>int</b>
    operand and emits that many beeps.
  Finally, assume that the following code is called once a minute by the
    operating system; when we study Java <b>threads</b> we will learn how to
    arrange for such an action to occur repeatedly;.<b><pre>
    if (minute != 59)
      minute++;
    else {
      emitBeeps(hour+1);
      minute = 0;
      if (hour != 23)
        hour++;
      else
        hour = 0;
    }</b></pre>
  Each time the code is called, it advances <b>minute</b> (and <b>hour</b>, if
   necssary) ensuring they store only legal values; on the hour, the code beeps
    that many times (once at 1 am, twice at 2am, ... 12 times at noon, 13 times
    at 1pm, ..., and 24 times at midnight).
  Let's write two trace tables for hand simulating this code in two different
    initial situations: first at 10:15 (10:15am).
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>hour</th><th>minute</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>10</td><td>15</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>if (minute != 59)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>
  <tr valign="top"><td>minute++;</td><td>&nbsp</td><td>16</td><td>&nbsp</td><td><b>if/else</b> finished</td>
  </tbody>
  </table>
  <p>
  Here, the minute is incremented by 1, and nothing else happens.
  <p>
  Now lets write a trace table for the initial situation 22:59 (10:59pm).
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>hour</th><th>minute</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>22</td><td>59</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>if (minute != 59)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute statement after <b>else</b></td>
  <tr valign="top"><td>emitBeeps(hour+1);</td><td>&nbsp</td><td>&nbsp</td><td>Beep 23 times</td><td>1st statement in block</td>
  <tr valign="top"><td>minute = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>2nd statement in block</td>
  <tr valign="top"><td>if (hour != 23)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>
  <tr valign="top"><td>hour++;</td><td>23</td><td>&nbsp</td><td>&nbsp</td><td>inner <b>if/else</b> finished, and outer <b>if/else</b> finished</td>
  </tbody>
  </table>
  <p>
  Here, much more happens: the clock beeps 23 times (for 11:00pm) and the
    minute is reset to 0 while the hour advances to 23.
</td>
</tbody>
</table>


<!-- A Caution -->

<a name="ACaution"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>A Caution: = vs ==<br>in ifs</b></td>
<td width ="80%">
  Imagine that you want to write code that doubles the value stored in an
    <b>int</b> variable <b>x</b>, but only if it stores <b>10</b>. 
  The following <b>if</b> statement proposes to solve the problem
<pre><b>   if (x = 10)
     x = 2*x;</b></pre>
  Carefully examine the test, it is written as <b>x = 10</b> not
     <b>x == 10</b>.
  Did you see that the first time you read it?
  Most students don't.
  <p>
  It is a common mistake for programmers to write <b>=</b> accidentally
     instead of <b>==</b>  in <b>if</b> tests.
  But the good news is that the Java compiler will detect and report a
   syntax constraint error, because the result type of the test is not
   <b>boolean</b>.
  <p>
  There are situations, though, where the Java compiler will not detect such a
    mistake will not be detected: when the expression itself is of type
    <b>boolean</b>.
  The code on the left uses <b>=</b> and the one on the right uses <b>==</b>.
<pre><b>  boolean doIt = ...;                    boolean doIt = ...;
  if (doIt == true)                        if (doIt = true)
    System.out.println("Yes");               System.out.println("Yes");</b></pre>
  Assume in both cases the the <b>...</b> code evalutes to <b>false</b>.
  The left test evaluates to <b>false</b>, so it does not print the message.
  But the right test stores <b>true</b> into <b>doIt</b> (wiping out the
    value computed before the <b>if</b>) AND evaluates to <b>true</b> (by
    the semantics of the <b>=</b> operator), so it does print the message.
  The Java compiler does not report any error, because the type of the
    expression in both cases is <b>boolean</b>.
  <p>
  This brings us to a style point: writing <b>== true</b> or <b>== false</b>
    in an <b>if</b>'s test is unnecessary, and is prone to error.
  For any <b>boolean</b> expression <b><i>e</i></b>, we can write just
    <b><i>e</i></b> (instead of <b><i>e</i> == true</b>) and
    we can write <b>!<i>e</i></b> (instead of <b><i>e</i> == false</b>).
  Avoiding the <b>true</b> and <b>false</b> literals here is the sign of a
     mature programmer. 
  <p>
  Finally, as we have already seen, if you accidentally write the expression
    statement <b>x == 0;</b> the Java compiler will detect and report a
    syntax constraint error, because the last operator applied in this
    expression statement is not a state-change operator.
  Older languages (C and C++) allow these expression statements, and cause
    programmers no  end of debugging problems, so Java disallowed them,
    instead forcing them to be reported during compilation.
</td>
</tbody>
</table>



<!-- Dangling Else -->

<a name="DanglingElse"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Dangling else</b></td>
<td width ="80%">
  Examine the following two <b>if</b> statements<pre><b>   if (test<sub>1</sub>)             if (test<sub>1</sub>)
     if (test<sub>2</sub>)             if (test<sub>2</sub>)
       statement<sub>1</sub>             statement<sub>1</sub>
     else                else
       statement<sub>2</sub>           statement<sub>2</sub></b></pre>
  The left code looks like it has an <b>if/else</b> inside an <b>if</b>.
  The right code looks like it has an <b>if</b> inside and <b>if/else</b>.
  But what we see is based on whitespace/indentation.
  What Java sees for both is EXACTLY THE SAME TOKENS:
    <b>if (test<sub>1</sub>) if (test<sub>2</sub>) statement<sub>1</sub> else statement<sub>2</sub></b> because
    whitespace is removed once Java tokenizes a program.
  <p>
  So, Java interprets both code fragments in exactly the same way!
  Which interpretation does Java use for these tokens?
  We need an extra syntax rule that helps us gree on which interpretion is
     the correct one: an <b>else</b> belongs to the most recently seen
     <b>if</b> that it can belong to.
  So, Java uses the left interpretation.
  <p>
  To force the other interpretation, matching the <b>else</b> with the first
     <b>if</b>, we must use a block, and write
<pre><b>   if (test<sub>1</sub>) {
     if (test<sub>2</sub>)
       statement<sub>1</sub>
   }else                 
     statement<sub>2</sub></b></pre>
   Now the <b>else</b> (which is outside the block) cannot possibly belong to
     the <b>if</b> that is inside the block, because all parts of that
     <b>if</b> statement must reside entirely in the block.
   So the final <b>else</b> now belongs with the first <b>if</b>.
  <p>
  This is called th dangling else problem, and it is hard for programmers
    to see.
  We must carefully indent our <b>if</b> statements accurately, to reflect
    which <b>else</b>s belong with which <b>if</b>, otherwise our program will
    contain a subtle error that is very hard for us to locate.
  In fact, some programmers advocate ALWAYS using block in
    <b>if</b>/<b>else</b> statements to avoid dangling elses.
  The disadvantage of this approach is that in simple cases, the extra
    blocks create code that is harder to read.
  We will discuss style principles in more detail later in the quarter.
</td>
</tbody>
</table>



<!-- If Pragmatics -->

<a name="IfPragmatics"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>if Pragmatics</b></td>
<td width ="80%">
  When writing decisions, determine the correct form: <b>if</b>,
     <b>if/else</b>, or <b>cascaded if</b>.
  If you are unsure about which one is correct, try the simpler forms first.
  <p>
  Indent the parts of the <b>if</b> and the statements that it contains to
    illustrate the logical structure of the <b>if</b>; when blocks are used,
    place the braces in the positions shown in the examples above.
  Ensure that the indentation (making the code easier for humans to read)
    accurately reflects how Java reads the tokens (e.g., beware of a dangling
    else).
  <p>
  The key to understanding an <b>if</b> statement is understanding its test(s).
  Ensure that for some values of its variables, every test can evaluate to
    both <b>true</b> and <b>false</b> (otherwise the test is probably wrong).
  For example, what is wrong with the following code?
  <p>
  Study it carefully and hand simulate it for a few different values of
    <b>x</b>.
<pre><b>  if (x > 2 || x < 5)
    x++;</b></pre>
  Is this test really the right one?
    probably not: no <b>int</b> value stored in <b>x</b> makes the test
    <b>false</b>; try to find one.
  If it were correctly, we could simplify this code by removing the whole
    <b>if</b> statement, simplifying it to just <b>x++</b>, which always
    performs this action.
</td>
</tbody>
</table>



<!-- For Statements -->

<a name="ForStatements"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>for Statements</b></td>
<td width ="80%">
  In Java, <b>for</b> statements allow us to repeatedly execute
  another statement.
<p>
  To begin, we present a simple, useful, legal, but incomplete, form for the
    <b>for</b> statement.
  The EBNF rule for this simplified <b>for</b> statement is
  <p>
  <i>for-statement</i> <= <b>for(;;)</b> <i>statement</i>
  <p>
  We call <i>statement</i> the <i>body</i> of the <b>for</b> loop.
  Although we write this EBNF rule on one line, we write <b>for</b> statements
    in code that span at least two (and often many more) lines.
  Finally, note that <b>for</b> is a keyword in Java.
  <p>
  The most typical form of the <b>for</b> statement is
<pre><b>   for (;;) {
     statements (i.e. a sequence of statements inside a block)
   }</b></pre>
  Here the body of the <b>for</b> is a block.
  <p>
  Semantically, Java executes the <b>for</b> statement by executing its body
    over and over again.
  Thus, when done executing the body, Java "loops back" and re-executes it.
  That is why we often refer to such a statement as a "for loop".
  Such a loop runs forever; or, more accurately, until Java executes a
    <b>break</b> statement inside the loop (discussed in the next section)
    forces Java to terminate the loop.
  Two example <b>for</b> loops (each infinite) are  <pre><b>   for (;;)
     System.out.println("You're Great!");


   int count = 0;
   for (;;) {
     System.out.println(count);
     count++;
   }</b></pre>
  The first example fills the screen with <b>Your're Great!</b>.
  The second example starts by displaying the value <b>0</b>, then <b>1</b>, then <b>2</b>,
    then <b>3</b>, etc. with the next value displayed becoming larger by one for each
    iteration.
  <p> 
  Let's hand simulate this second example and write a trace table for it.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>count</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int count = 0;</td><td>0</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>
  <tr valign="top"><td>System.out.println(count);</td><td>&nbsp</td><td>0</td><td>1st statement in block</td>
  <tr valign="top"><td>count++;</td><td>1</td><td>&nbsp</td><td>last statement in block</td>
  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>System.out.println(count);</td><td>&nbsp</td><td>0<br>1</td><td>1st statement in block</td>
  <tr valign="top"><td>count++;</td><td>2</td><td>&nbsp</td><td>last statement in block</td>
  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>System.out.println(count);</td><td>&nbsp</td><td>0<br>1<br>2</td><td>1st statement in block</td>
  <tr valign="top"><td>count++;</td><td>3</td><td>&nbsp</td><td>last statement in block</td>
  <tr valign="top"><td>...</td><td>...</td><td>...</td><td>...</td>
  </tbody>
  </table>
  <p>
  Of course, this process continues endlessly, so we cannot show a complete
    trace table for this code or any other infinite loop.
  You can always terminate a program in Eclipse by using by pressing the red 
    square in the console window, if you suspect your program is in an
    infinite loop and you want to stop it.
<p>
  In the next section, we will explain how the <b>break</b> statement
    allows the program itself to terminate the loop.
</td>
</tbody>
</table>



<!-- Break Statements -->

<a name="BreakStatements"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>break Statements</b></td>
<td width ="80%">
  The EBNF rule for the <b>break</b> statement is very simple
  <p>
  <i>break-statement</i> <= <b>break</b>;
  <p>
  Java imposes a syntax constraint that a <b>break</b> statement must appear
    inside the body of some loop.
  Finally, note that <b>break</b> is another keyword in Java.
  <p>
  In real programs, <b>break</b> statements appear inside <b>if</b> statements
    (which themselves are inside the bodies of loops), so a typical example is
<b><pre>   if (count == 0)
     break;</b></pre>
  Semantically, whenever a <b>break</b> statement is executed, Java terminates
    the inner-most loop that it apears in; it <i>breaks</i> out of that loop.
  Terminating a loop means Java next executes the statement AFTER the body of
    the loop (it does not mean that the program terminates).
  By putting a <b>break</b> statement inside an <b>if</b> statement, the
    <b>if</b> can control (based on its <b>test</b>) whether or not the
    <b>break</b> statement is executed: the <b>test</b> determines whether or
    not the loop terminates on this iteration.
  <p>
  A tyical combination of <b>for</b> and <b>break</b> statements is
<pre><b>   int countdown = 3;
   for(;;) {
     System.out.print(countdown + "...");
     if (countdown == 0)
       break;
     countdown--;
   }
   System.out.println("Blastoff");</b></pre>
  Let's hand simulate this example and write a trace table for it.
  We call such a <b>for</b>/<b>break</b> combination a <i>count down</i> loop.
</td>
</tbody>
</table>
  <p>

  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>countdown</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int countdown = 3;</td><td>3</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body first time</td>
  <tr valign="top"><td>System.out.print(countdown + "...");</td><td>&nbsp</td><td>3...</td><td>1st statement in block</td>
  <tr valign="top"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>countdown--;</td><td>2</td><td>&nbsp</td><td>last statement in block</td>
  <tr valign="top"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>
  <tr valign="top"><td>System.out.print(countdown + "...");</td><td>&nbsp</td><td>3...2...</td><td>1st statement in block</td>
  <tr valign="top"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>countdown--;</td><td>1</td><td>&nbsp</td><td>last statement in block</td>
  <tr valign="top"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>
  <tr valign="top"><td>System.out.print(countdown + "...");</td><td>&nbsp</td><td>3...2...1...</td><td>1st statement in block</td>
  <tr valign="top"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>countdown--;</td><td>0</td><td>&nbsp</td><td>last statement in block</td>
  <tr valign="top"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>
  <tr valign="top"><td>System.out.print(countdown + "...");</td><td>&nbsp</td><td>3...2...1...0...</td><td>1st statement in block</td>
  <tr valign="top"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement;</td>
  <tr valign="top"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>
  <tr valign="top"><td>System.out.println("Blastoff");</td><td>&nbsp</td><td>3...2...1...0...Blastoff</td><td>1st statement AFTER loop body</td>
  </td>
  </tbody>
  </table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
   We can graphically summarize the control flow in cooperating <b>for</b> and <b>break</b> statements
     as
</td>
</tbody>
</table>
<img src="images/forbreak.gif"></image><p>



<!-- More Examples -->

<a name="MoreExamples"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>More for/break Examples</b></td>
<td width ="80%">
  Let's look at two more interesting kinds of loops that combine <b>for</b>
     and <b>break</b>.
  The first is called a <i>count up</i> loop: the variable <b>x</b> counts
    up to the value stored in the variable <b>max</b>.
  Notice that <b>max</b> is declared and initialized by the value entered by
    the user.
 <b><pre>    int max = Prompt.forInt("Enter Number to Sum To");
    int x   = 0;       //Stores value to add to sum
    int sum = 0;       //Stores sum that x is added to

    for (;;) {
      if (x == max)
        break;
      x++;
      sum += x;
    }
    System.out.println("1+2+...+" + max + " = " + sum);</pre></b>
   Assuming the user enters <b>5</b> when prompted, let's hand simulate these
     statements and write a trace table for it.
</td>
</tbody>
</table>
  <p>

  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>max</th><th>x</th><th>sum</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int max = Prompt(...);</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...: 5&nbsp</td><td>&nbsp</td>

  <tr valign="top"><td>int x = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int sum = 0;</td><td>&nbsp</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td>
 
  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>
  <tr valign="top"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>x++;</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>x++;</td><td>&nbsp</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>x++;</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>x++;</td><td>&nbsp</td><td>4</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>10</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>x++;</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>15</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement</td>
  <tr valign="top"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>

  <tr valign="top"><td>System.out.println(...);</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...:5<br>1+2+...+5 = 15</td><td>1st statement AFTER loop body</td>
  </td>
  </tbody>
  </table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
The second example is called a <i>sentinel terminated</i> loop.
Here the user enters a special value (called a sentinel) to inform the program
  that there are no more values to input.
The sentinel is not processed by the normal code in the loop body<b><pre>    int count = 0;
    int sum   = 0;
    for (;;) {
      int score = Prompt.forInt("Enter a Score (-1 to Terminate)");
      if (score == -1)
        break;
      count++;
      sum += score;
    }
    System.out.println("Average = " + (double)sum/(double)count);</b></pre>
   Assuming the user enters the value <b>3</b>, <b>6</b>, <b>4</b>, and the
     sentinel <b>-1</b> respectively when prompted, let's hand simulate these
     statements and write a trace table for it.
</td>
</tbody>
</table>

  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>count</th><th>sum</th><th>score</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int count = 0;</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int sum = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>
  <tr valign="top"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>Enter ...: 3</td><td>&nbsp</td>
  <tr valign="top"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>count++;</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= score;</td><td>&nbsp</td><td>3</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>Enter ...: 3<br>Enter ...: 6</td><td>&nbsp</td>
  <tr valign="top"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>count++;</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= score;</td><td>&nbsp</td><td>9</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>4</td><td>Enter ...: 3<br>Enter ...: 6<br>Enter ...: 4</td><td>&nbsp</td>
  <tr valign="top"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>
  <tr valign="top"><td>count++;</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>sum+= score;</td><td>&nbsp</td><td>13</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>

  <tr valign="top"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>
  <tr valign="top"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>-1</td><td>Enter ...: 3<br>Enter ...: 6<br>Enter ...: 4<br>Enter ...: -1</td><td>&nbsp</td>
  <tr valign="top"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement</td>
  <tr valign="top"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>Undeclared</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>

  <tr valign="top"><td>System.out.println(...)</td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Average = 4.3333333</td><td>1st statement AFTER loop body</td>
  </td>
  </tbody>
  </table>

<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
<p>
  Notice that each time that the <b>for</b> loop executes its body, it
    declares, intializes, then undeclares its local variable <b>score</b>.
  This variable could be declared and left uninitialized before the loop, as
    <b>int score;</b> and then appear in the loop as just
    <b>score = Prompt.forInt("Enter a Score (-1 to Terminate)");</b>.
  But because the values stored in this variable are never (and should never
    be)used outside the loop, we have chosen to not even declare this variable
    outside the loop.
  The fact that this variable is declared/undeclared many times does not
    affect the correctness (nor the speed) of this code.
  </td>
  </tbody>
  </table>
</td>
</tbody>
</table>



<!-- Compact Trace Tables -->

<a name="Compact"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Compact Trace Tables</b></td>
<td width ="80%">
  When we hand simulate programs with complicated control structures, most of 
    the trace table is occupied by information relating to control structures
    deciding which statements to execute next, as opposed to statements that
    actually change the state of variables or the console window.
  Such trace tables are cumbersome to create and hard to read.
  <p>
  Compact trace tables remove all the information related to control
     structures, and instead focus on state changes to variables and the
     console window.
  To construct a compact trace table, we list all variables and <b>Console</b>
    in separate columns (and omit <b>Explanation</b>).
  Only when the code changes the state of a variable OR the console window do
    we update information in the appropriate column; and we always do so
    right beneath the last entry for this column.
  <p>
  Note that what we lose in a compact trace table (we gain conciseness) is an 
    indication of the order in which different variables have their state
    changed: because each column is shown as compactly as possible (no blank
    entries); there is no correlation among columns whose states changed.
  Here are compact trace tables for the three standard trace tables shown
    above.
  First, the <i>count down</i> loop.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">countdown</th><th>Console</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Undeclared</td><td>(blank)</td>
  <tr valign="top"><td>3</td><td>3...</td>
  <tr valign="top"><td>2</td><td>3...2...</td>
  <tr valign="top"><td>1</td><td>3...2...1...</td>
  <tr valign="top"><td>0</td><td>3...2...1...0...</td>
  <tr valign="top"><td>&nbsp</td><td>3...2...1...0...Blastoff</td>
  </td>
  </tbody>
  </table>
  <p>
  Next, the <i>count up</i> loop.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">max</th><th>x</th><th>sum</th><th>Console</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>(blank)</td>
  <tr valign="top"><td>5</td><td>0</td><td>0</td><td>Enter Number to Sum To: 5</td>
  <tr valign="top"><td>&nbsp</td><td>1</td><td>1</td><td>1+2+...+5 = 15</td>
  <tr valign="top"><td>&nbsp</td><td>2</td><td>3</td><td>&nbsp</td>
  <tr valign="top"><td>&nbsp</td><td>3</td><td>6</td><td>&nbsp</td>
  <tr valign="top"><td>&nbsp</td><td>4</td><td>10</td><td>&nbsp</td>
  <tr valign="top"><td>&nbsp</td><td>5</td><td>15</td><td>&nbsp</td>
  </td>
  </tbody>
  </table>
  <p>
 Finally, the <i>sentinel terminated</i> loop.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">count</th><th>sum</th><th>score</th><th>Console</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>(blank)</td>
  <tr valign="top"><td>0</td><td>0</td><td>3</td><td>Enter a Score (-1 to Terminate): 3</td>
  <tr valign="top"><td>1</td><td>3</td><td>6</td><td>Enter a Score (-1 to Terminate): 6</td>
  <tr valign="top"><td>2</td><td>9</td><td>4</td><td>Enter a Score (-1 to Terminate): 4</td>
  <tr valign="top"><td>3</td><td>13</td><td>-1</td><td>Enter a Score (-1 to Terminate): -1</td>
  <tr valign="top"><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Average = 4.333333</td>
  </td>
  </tbody>
  </table>
  <p>
  Remember, in a compact trace table, all the blank entries are at the bottom
    of a column.
  A column entry is filled in only when all the column entries on top of it
    have been filled in.
</td>
</tbody>
</table>



<!-- General for statement -->

<a name="GeneralFor"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>General for/break; while/do</b></td>
<td width ="80%">
  We can write ANY looping code using the <b>for</b> and <b>break</b> that we
    know; but, there is a more general form of the <b>for</b> statement that
    allows use to write many loops more compactly and clearly.
  When we study arrays, iterators, and self referential objects, these forms
    will become more and more useful.
  <p>
  The general <b>for</b> statement packages all the information needed for a
    count-down or count-up loop into one locality, making it easier to read,
    write, and understand.
  The EBNF rule for the general <b>for</b> statement is
  <p>
  <i>expression-list</i> <= <i>expression</i>{<b>,</b><i>expression</i>}<br>
  <i>for-init</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>type variable-declarators</i> | <i>expression-list</i><br>
  <i>for-update</i> &nbsp &nbsp &nbsp <= <i>expression-list</i><br>
  <i>for-statement</i> &nbsp<= [<i>identifier</i>:] <b>for(</b>[<i>for-init</i>]<b>;</b>[<i>expression</i>]<b>;</b>[<i>for-update</i>]<b>)</b> <i>statement</i>
  <p>
  Note that if we discard all the options, we are back at the <b>for(;;)</b>
    statement that we have studied.
  As a syntax constraint, if the <i>expression</i> option (in the middle of the
    semi-colons) is included, its resulting type must <b>boolean</b>: this
    part is called the continuation test.
  Also, each <i>expression</i> in an <i>expression-list</i> must adhere to the
    same constraints as an <i>expression-statement</i>: it must apply a
    state-change operator or a method call last in the expression.
  <p>
  For example, we can use such a <b>for</b> statements to simplify the code
    that sums all the integers up to <b>max</b>.
  <b><pre>  int max = Prompt.forInt("Enter Number to Sum To)";
  int sum = 0;       //Holds Sum of 1..x

  for (int x=1; x<=max; x++)
    sum += x;
  System.out.println("1+2+...+" + max + " = " + sum);</pre></b>
  The <b>for</b> loop is so powerful that it reduces the body of the loop to a
     single expression statement.
  <p>
  Semantically the <b>for</b> loop executes as follows.
  <ol>
    <li>Execute the code specified in <i>for-init</i>
        (in the example, the declaration <b>int x=1</b>: if <i>for-init</i> is
         a declaration, the scope of the variable(s) declared is the
         <b>for</b> statement; any disappear when the loop terminates.
    <li>Evaluate the test as specified in the <b>boolean</b> <i>expression</i>
          (in this example <b>x <= max</b>): if <b>true</b> execute the body
          of the <b>for</b> loop; if <b>false</b> terminate the <b>for</b>
          loop.
        If the <b>expression</b> is omitted, execute the body of the <b>for</b>
          loop.
    <li>After executing the entire body of the <b>for</b>, evaluate
          <i>for-update</i> (in the example <b>x++</b>: note that the last
          operator applied here is a stat-change operator).
    <li>Continue back at step 2 (in the example, checking the continuation
         test for the new value stored in <b>x</b>).
  </ol>
  <p>
  Pictorially, the semantics look like<p>
  <img src="images/forcontrol.gif"></image><p>
  What makes the <b>for</b> loop so powerful is the way it groups together,
    in one locality, all the information that controls the loop.
  Here is a standard (not compact) trace table illustrating these semantics
    in the code above.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Statement</th><th>max</th><th>x</th><th>sum</th><th>Console</th><th>Explanation</th>
  </thead>
  <tbody>
  <tr valign="top"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int max = ...;</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...: 5&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>int sum = 0;</td><td>&nbsp</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td>
  <tr valign="top"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>Initialize; test is <b>true</b> execute body</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>last statement in body</td>
  <tr valign="top"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>last statement in body</td>
  <tr valign="top"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>&nbsp</td><td>last statement in body</td>
  <tr valign="top"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>4</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>10</td><td>&nbsp</td><td>last statement in body</td>
  <tr valign="top"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>
  <tr valign="top"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>15</td><td>&nbsp</td><td>last statement in body</td>
  <tr valign="top"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>false</b> terminate loop</td>
  <tr valign="top"><td>System.out.println(...);</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...:5<br>1+2+...+5 = 15</td><td>1st statement AFTER loop body</td>
  </td>
  </tbody>
  </table>
  <p>
  Note that the variable <b>x</b> becomes undeclared after the <b>for</b>
    statement terminates.
  Thus, we cannot refer to it after the <b>for</b> loop's body (where we print
     the statistics); if we did write its name there, the Java compiler would
     detect and report an error.
  If we did want to refer to this value AFTER the <b>for</b> statement
    finishes, we could write
  <b><pre>  int max = Prompt.forInt("Enter Number to Sum To)";
  int sum = 0;       //Holds Sum of 1..x

  int x = 1;
  for (; x<=max; x++)
    sum += x;
  System.out.println("1+2+...+" + max + " = " + sum + " and x = " + x);</pre></b>
  Here, <b>x</b> is declared before the <b>for</b> statement, not in it, so it
    remains declared after the <b>for</b> statement finishes.
  Note that in this <b>for</b> statement, nothing appears before the first
    semi-colon. 
  <p>
  Finally, a <b>for</b> statement can be named by an <i>identifier</i>
    (see the first option in the EBNF).
  Likewise, there is a more general <b>break</b> statement whose EBNF is
    <p>
    <i>break-statement</i> <= <b>break</b> [<i>identifier</i>] ;
    <p>
  In a simple <b>break</b> statement, Java terminates the inner-most
    loop that the <b>break</b> apears in.
  If a general <b>break</b> statement includes this option, it has a
     syntax constraint that it must appear inside a loop named by that same
     <i>indentifier</i>, and it terminanes that loop.
  This feature is only useful for loops inside loops, and even then it is
    very very rarely needed.
</td>
</tbody>
</table>
<p>


<a name="WhileDo"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>for,while,do Semantics</b></td>
<td width ="80%">
  We will now show the EBNF rule for <b>while</b> and <b>do</b> statements and 
    explain their semantics, and the general <b>for</b> statement, by using
    the simple <b>for</b> and <b>break</b> statements.
  The EBNF for <b>while</b> and <b>do</b> statements is
  <p>
  <i>while-statement</i> <= <b>while</b>(<i>expression</i>) <i>statement</i><br>
  <i>do-statement</i> &nbsp &nbsp <= <b>do</b> <i>statement</i> <b>while</b> (<i>expression</i>);
  <p>
  Semantically, we can mechanically translate any general <b>for</b> loop,
    <b>while</b> loop, or <b>do</b> loop into an equivalent simple
    <b>for(;;)</b> loop.
  The Java compiler performs just this kind of transformation when it
    generates the machine instructions corresponding to these kinds of loops.
  <b><pre>
  for (init; continue; update)       {
    statement                          init;
                                       for (;;) {
                                         if ( !(continue) )
                                           break;
                                         statement
                                         update
                                       }
                                      }


   while (continue)                   for(;;) {
     statement                          if ( !(continue) )
                                          break;
                                        statement
                                      }
                        or even

                                     for(;continue;)
                                       statement

   do                                 for(;;) {
     statement                          statement
   while (continue)                     if ( !(continue) )
                                          break;
                                      }</pre></b>
  For the general <b>for</b> statement example above, this means
  <b><pre>  for (int x=1; x<=max; x++)      {
    sum += x;                       int x=1;
                                    for (;;) {
                                      if (!(x<=max))
                                        break
                                      sum += x;
                                      x++;
                                    }
                                  }</pre></b>
  Note that the value of <b>x</b> is declared inside a special block (the
    outermost one); as described above, this variable disappears when the
    <b>for</b> statement (the outermost block shown above in the translation)
    terminates. 
  <p>
  The <b>while</b> and <b>do</b> statements and just variants where the
     continuation condition is always tested first or last in the loop's
     body.
  In the case of the <b>do</b> loop, the body is always executed once.
  Pragmatically, you will see many more <b>while</b> loops than <b>do</b>
    loops.
 <p>
 Finally, most students have two problems understanding general <b>for</b>
    loops.
 <ul>
   <li>They don't realize when the <b>update</b> is done: it is done AFTER the
         loop body, right BEFORE <b>continue</b> is retested.
       Also note that <b>x++</b> and <b>x=x+1</b> are valid expression
         statements that can be used in <b>update</b> (but <b>x+1</b> is not,
         because it contains no state-change operator)
   <li>They try to use the variable declared in <b>init</b> outside the loop,
         after it has terminated: this variable can be used only inside the
         loop.
 </ul>
</td>
</tbody>
</table>



<!-- For/Break Pragmatics -->

<a name="ForBreakPragmatics"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>for/break Pragmatics</b></td>
<td width ="80%">
  The following rules can help you synthesize and analyze (to fix bugs) loops.
  When designing iterative code, think in terms of the simple <b>for</b> and
    <b>break</b> statements and determine:
  <ul>
    <li>What statements belong before the loop (initialization code)
    <li>What statements belong inside the body of the loop
    <li>What condition terminates the loop
    <li>Where that condition should be tested inside the loop
  </ul>
  Each iteration should allow some progress towards the termination condition
     of the loop (making the <b>if test true</b>).
  Sometimes it is easier to write the body of the loop first, and then
    determine what initialization is necessary before the loop.
  <p>
  Sylistically, write loops as shown, with block braces as shown and the body
    of the loop slightly indented (typically 2 spaces).
  <p>
  When hand simulating loops, pay special attention to the first few and last
    few iterations (certain kinds of errors occur only at the beginning or
    ending of a loop).
  Ensure that all the variables are properly initialized before they are
    examined in expressions (the Java compiler will help you here).
  Errors due to incorrect initialization are easy to spot if we carefully hand
    simulate the first iteration of a loop (and these are among the most
    frequent category of errors).
  <p>
  The <b>break</b> statement is the most important statement inside a loop.
  Clearly mark <b>break</b> statements using white space and/or special
    comments (e.g., a comment sandwich).
  Ensure that for all possible initial states of its variables, a loop
    eventually terminates (the <b>test</b> in the <b>if</b> statement
    containing the <b>break</b> will always eventually evaluate to
    <b>true</b>).
  <p>
  Most loops, even in industrial code, need one <b>if</b>/<b>break</b>
    combination.
  A loop to solve a very complicated problem may require multiple 
    <b>if</b>/<b>break</b> combinations, but they can often be localized
    (grouped together).
  Only a loop that solves the most complicated kind of problems may require
    multiple <b>if</b>/<b>break</b> combinations distributed throughout the
    loop's body.
  <p>
  It is the mark of a good programmer to write simple loops with simple
      terminations.
  The most frequent occuring location for the <b>if</b>/<b>break</b> is the
    first statement in the body of the <b>for</b> loop (try it there first,
    move it elsewhere if necessary).
  Such a <b>for/break</b> combination can also be written as a <b>while</b>
    loop.
  <p>
  Finally, use the general form of the <b>for</b> statement to its maximum 
    advantage, to clarify your loops.
  You may use <b>while</b> and <b>do</b> loops, but the extra thought that
    goes into considering them, and the fact that it is often harder to think
    of a "continuation" condition rather than a "termination" condition, means
    that I use them infrequently, preferring the <b>for/break</b> combination.
</td>
</tbody>
</table>



<!-- Boxing Statements -->

<a name="Boxing2">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Boxing if, for, and break Statements</b></td>
<td width ="80%">
  Continuing our analysis of boxing statements, we illustrate below how to box
    <b>if</b>, <b>for</b> and <b>break</b> statements (as well as expression
    and block statements).
  Notice that EVERYTHING that can be syntactically considered to be a
    statement is in its own box.
  This includes declarations statements (there are none here), expression
    statements, blocks, entire <b>if</b> statements, <b>break</b> statements,
    and entire <b>for</b> statements. 
</td>
</tbody>
</table>
<img src="images/boxed2.gif"></image><p>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  General <b>for</b> loops are boxed in a similar manner; none of the
    information within their parentheses are considered statements.
</td>
</tbody>
</table>



<!-- Try-Catch -->

<a name="TryCatch"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>try-catch</b></td>
<td width ="80%">
  The EBNF of the <b>try-catch</b> statement is the most complex of any
    control structure that we have seen so far: that is a tipoff that
    programming in Java with exception handling is interesting.
  In fact, many Java courses don't cover exceptions and exception handling
    until much later in the quarter.
  But, I think that the core concepts can be demonstrated early, can be used
    to good advantage in stereotypical ways that are easy to understand, and
    can be returned to repeatedly in more complicated contexts (a spiral
     approach to learning).
  The general form of a <b>try-catch</b> statement is
  <p>
  <i>parameter</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>type</i> <i>identifier</i><br>
  <i>catch-clause</i> &nbsp  &nbsp &nbsp &nbsp &nbsp &nbsp<= <b>catch</b> (<i>parameter</i>) <i>block-statement</i><br>
  <i>try-catch-statement</i> <= <b>try</b> <i>block-statement</i> {<i>catch-clause</i>}[<b>finally</b> <i>block-statement</i>]
  <p> 
  Although we write the <i>try-catch-statement</i> EBNF rule on one line,
    <b>try-catch</b> statements written in our code often span many 
    lines (they contain mandatory blocks, which can contain many statements
    on different lines).
  The names of exceptions are actually special reference types.
  Although this is getting a bit ahead of ourselves, we will use the following
    reference types/exception names: <b>ArithmeticException</b>,
    <b>NumberFormatException</b>, <b>IllegalArgumentException</b>,
    <b>IllegalStateException</b>, <b>IOException</b>, and <b>Exception</b>
    (a generic name that includes all the others). 
  <p>
  As a syntax constraint, the right hand side of each
    <i>try-catch-statement</i> must have at least one <i>catch-clause</i> or
    one <b>finally</b>; there can be many of the former, and a combination
    of both, but we cannot take 0 repetitions of <i>catch-clause</i> and at
    the same time discard the <b>finally</b> block.
  We could actually encode this restriction in EBNF, but it would make a
    complicated description look even more complex.
  <p>
  The semantics of this statement, as you might expect, are complicated as
    well.
  Java starts a <b>try-catch</b> by sequentially executing the statements
    in the <i>block-statement</i> immediately following the keyword <b>try</b>
   (known as the <b>try</b> block), just as it would execute any block.
  One of two things happen.
  <ul>
    <li>If no statement in the <b>try</b> block throws an exception, after the 
         last statement in the block is executed, Java executes the
         <b>finally</b> block (if this option was included).
       Java is now done with the <b>try-catch</b> statement and executes the
          next statement following it.
    <p>
    <li>If some statement in the <b>try</b> block throws an exception, the rest
          of the statements in that block are skipped.
        Java tries to find a <i>catch-clause</i> whose <i>parameter</i>
          matches the name of the exception that was thrown; the generic name
          <b>Exception</b> matches all exception names.
        <ul>
          <li>If the name is found, Java executes its associate block, and
               then Java executes the <b>finally</b> block (if this option was
               included).
              Java is now done with the <b>try-catch</b> statement and executes
                the next statement following it.
          <li>If the name is NOT found, Java executes the <b>finally</b> block
                (if this option was included).
              Java then skips code while it looks for another, more outer
                 <b>try-catch</b> statement: one whose
                 <i>catch-clause</i> does name the exception.
              <ul>
                <li>If one is found, follow the rule above.
                    Note that it DOES NOT return to the original, inner
                    <b>try-catch</b> statement.
                 <li>If one is NOT found, Java terminates the programs, citing
                       an uncaught exception.
                     Typically, this results in a trace: it prints on the
                       console the name of the uncaught exception and what
                       methods were active when the exception was thrown.
              </ul>
        </ul>
  </ul>
</td>
</tbody>
</table>


<!-- An Example -->

<a name="AnExample"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>A Simple Example</b></td>
<td width ="80%">
  In this section we will present a simplified example: it is not useful in
    real programs, but is useful only to illustrate the semantics of 
    <b>try-catch</b> statements.
  Recall that the <b>/</b> operator throws an exception named
    <b>ArithmeticException</b> if its second operand is zero.
  Let us examine the effect of placing the following <b>try-catch</b>
    statement in a program.
<pre><b>  int percentage;
  ...some code
  try {
    int attended = Prompt.forInt("Enter attendance");
    int capacity = Prompt.forInt("Enter capacity");
    percentage = 100*attended/capacity;
    System.out.Println("percentage computed ok");
  }
  catch (ArithmeticException a) {
    System.out.println("capacity was 0; I'll assume percentage was 100%");
    percentage = 100;
  }
  ... more code</b></pre>
  Here, if the division succeeds, <b>percentage</b> is set correctly, the
    "ok" message is printed, the <b>try</b> block finishes normally, and
    execution continues afterward, where it says <b>...more code</b> 
    (because there is no <b>finally</b> block).
  <p>
  On the other hand, if the division fails (throwing
     <b>ArithmeticException</b>), <b>percentage</b> is not set (the <b>=</b>
    operator is never evaluted; it requires the result from the division which
    we have just seen has thrown an exception) the "ok" message is skipped as
    Java locates the appropriate <i>catch-clause</i>; both statements in the
    <i>catch-clause</i> block are executed, then the <b>try</b> block finishes,
    and execution again continues afterward, where it says <b>...more code</b>
    (because there is no <b>finally</b> block).
  <p>
  If we replaced <b>ArithmeticException</b> by <b>Exception</b> then the code
    would execute identically, because <b>Exception</b> matches all raised
    exceptions.
  If we replaced <b>ArithmeticException</b> by any other name, say
    <b>IOException</b> then Java would not find a matching exception;
    assuming that there is no outer <b>try-catch</b> statement to catch this
    exception, Java would terminate the program and print a trace on the
    console.
  <p>
  One reason why this example is not realistic is that we can easily check
    whether the division will fail with an <b>if</b> statement and avoid the
    need for a <b>try-catch</b> statement all together.
<pre><b>  int percentage;
  ...some code
  int attended = Prompt.forInt("Enter attendance");
  int capacity = Prompt.forInt("Enter capacity");
  if (capacity != 0) {
    percentage = 100*attended/capacity;
    System.out.Println("percentage computed ok");
  }else {
    System.out.println("capacity was 0; I'll assume percentage was 100%");
    percentage = 100;
  }
  ... more code</b></pre>
  In the following two examples, which are much more realistic, we will need a
    <b>try-catch</b> statement to solve the problem: we cannot use an
    <b>if</b> statement to check whether an exception is about to be thrown.
</td>
</tbody>
</table>



<!-- A Prompting Example-->

<a name="Prompting"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Prompting with try-catch</b></td>
<td width ="80%">
  In this section we will present a more realistic example.
  In fact, similar code appears inside the <b>Prompt.forInt</b> method.
  Understanding how this code works requires a mastery of the semantics of many
    Java statements.
  First, we must know that the <b>Integer.parseInt</b> method (from the Java
    library) has the following prototype
  <pre><b>int Integer.parseInt(String) throws NumberFormatException</b></pre>
  This methods takes a <b>String</b> as an argument.
  If that argument represents the value of a legal integer, it returns that
    value as an <b>int</b>; if it does not represent a legal integer, it
    cannot return any reasonable value, so it throws
    <b>NumberFormatException</b>.
  <p>
  Thus  <b>Integer.parseInt("-10")</b> returns the <b>int -10</b> and
  <b>Integer.parseInt("-1x0")</b> throws <b>NumberFormatException</b>.
  There is no method that Java provides to check whether
    <b>Integer.parseInt</b> will throw an exception: we have to call that
    method to see what it does.
  <p>
  Now, let us see how the following code, a combination of a <b>for</b> loop,
    <b>break</b> statement (not in an <b>if</b>!) and <b>try-catch</b>,
    prompts the usre until he/she enters a valid integer, whose value is
    stored into <b>answer</b>
  <pre><b>  int answer;
  for(;;)
    try {
      answer = Integer.parseInt(Prompt.forString("Enter integer"));
      break;
    }
    catch (NumberFormatException e) {
      System.out.println("Error: please enter a valid integer");
    }
  ...process answer</b></pre>
  Here, the <b>for</b> loop repeatedly executes the <b>try-catch</b> statement.
  First, let us see what happens if the user enters a valid integer.
  During the first iteration of the loop, Java executes the first statement;
    the user enters a valid integer (read as a <b>String</b> that is passed to
    the <b>Integer.parseInt</b> method); so, this method does not throw an
    exception, but instead returns a result that is stored in <b>answer</b>.
  Thus, the second statement in the block is reached; this <b>break</b>
    statement terminates the entire <b>for</b> loop, and execution continue 
   after the <b>for</b> loop, where it says <b>...process answer</b>.
  <p> 
  Now, let us see what happens if the user enters an INVALID integer.
  During the first iteration of the loop, Java executes the first statement;
    the user enters an invalid integer (read as a <b>String</b> that is passed
    to the <b>Integer.parseInt</b> method); so, this method throws a
    <b>NumberFormatException</b>.
  Java skips the <b>break</b> statement and instead finds the <b>catch</b>
    matching the exception; its following block prints an error message.
  Now the <b>try-catch</b> statement is finished; but this statement is the
    body of a <b>for</b> loop, so it is executed again!
  <p>
  Therefore, this loop will continue executing so long as the user enters an
    invalid integer; the first time that the user enters a valid integer (see
    the description above) its value will be stored into <b>answer</b> and
    the <b>break</b> statement following it will be executed to terminate the
    loop.
  <p>
  So generally, we have designed code that (potentially) repeatedly performs
    some operation until an exception is NOT thrown.
  In the next section, we will design code that repeatedly performs some
    operation until an exception IS thrown: e.g., we are anticipating that
    an exception will eventually terminate the loop, which continues executing
    until it is does.
  Together, these two forms occur frequently in exception handing code.
</td>
</tbody>
</table>



<!-- A File/Reading Example-->

<a name="FileReading"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Reading Files with try-catch</b></td>
<td width ="80%">
  In this section we will present another realistic example.
  In fact, code similar to this will be present in most programs that read
     files.
  First, we must learn that the <b>readInt</b> method (from a Java library
    class that I have written) has the following prototype
  <pre><b>int readInt() throws NumberFormatException, EndOfFileException</b></pre>
  This method skips any white space in a file and returns the next integer
    value that it contains (if it succeeds).
  There are two ways for it to fail, each denoted by a different exception
    name.
  <ol>
    <li>There is a value in the file, but it is not an integer; in this case
          the method throws <b>NumberFormatException</b>.
    <li>There are no more values (of any type) in the file; in this case the
          method throws <b>EndOfFileException</b>.
  </ol>
  The following code assumes the variable <b>inputFile</b> refer to an object
    representing a file (we'll learn more about this in a later lecture).
  It reads every value in a file, accumulating the sum, and ultimately
    printing it.
  <pre><b>  int sum = 0;
  for (;;)
    try {
      int aValue = inputFile.readInt();
      sum += aValue;
    }
    catch (EndOfFileException eofe) {
     break;
    }
  System.out.println("Sum = " + sum);</b></pre>
  Let us see what happens if the file contains two integers.
  <ol>
  <li>Java starts to execute the <b>for</b> loop, which contains just one
     statement: a  <b>try</b> block,
  During this first iteration of the loop, Java executes the first statement in
    the <b>try</b>. block; calling the <b>readInt</b> method reads a valid
    integer from the file and stores into <b>aValue</b>.
  In the next statement the <b>sum</b> is incremented by this value.
  The <b>try</b> block is finished, and the <b>for</b> loop executes it a
    second time.
  <li>During the second iteration of the loop, Java executes the first
    statement in the <b>try</b>. block; calling the <b>readInt</b> method reads
    another valid integer from the file stores into <b>aValue</b>.
  In the next statement the <b>sum</b> is incremented by this new value.
  The <b>try</b> block is finished, and the <b>for</b> loop executes it a
    third time.
  <li>During the third iteration of the loop, Java executes the first
    statement in the <b>try</b>. block; calling the <b>readInt</b> methods
    causes it to throw <b>EndOfFileException</b>, because there are no more
    values in the file to read.
  This error is caught by the <b>catch (EndOfFileException eofe)</b> clause,
     whose block contains a <b>break</b> statement that terminates the
     <b>for</b> loop.
  Java continues by executing the statement after the <b>for</b> loop,
     printing the accumulated sum.
  </ol>
  <p>
  This code repeatedly performs some operation until an exception is
     thrown.
  Note that if a non-integer value appears in the file, then calling the
    <b>readInt</b> method causes it to throw <b>NumberFormatException</b>.
  This exception is not caught by the <b>try-catch</b> shown above, so 
    Java terminates the program and prints a trace on the console.
  <p>
  Finally, because the only place that <b>aValue</b> is used is to add to
     <b>sum</b>, we can simplify this code a bit and write.
  <pre><b>  int sum = 0;
  for (;;)
    try {
      sum += inputFile.readInt();
    }
    catch (EndOfFileException eofe) {
      break;
    }
  System.out.println("Sum = " + sum);</b></pre>
</td>
</tbody>
</table>




<!-- Problem Set -->

<a name="ProblemSet"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem Set</b></td>
<td width ="80%">
  To ensure that you understand all the material in this lecture, please solve
    the the announced problems after you read the lecture.

  <p>
  If you get stumped on any problem, go back and read the relevant part of the
     lecture.
  If you still have questions, please get help from the Instructor, a CA, or any other student.
  <ol>
    <li>Explain which of the following state-change expressions are legal and illegal.
        Assume we have declared <b>int a,b,c;</b>.
        <b><pre>   a + b = c;
   a = 2++;
   (a = b) = c;
   a = Prompt.forInt("Enter a") + b;
   a = System.out.println("Success!");</pre></b>
    
    <p>
    <li>In each of the following expression statements, carefully apply your knowledge of syntax
          (tokens, operator precedence, and associativity) and semantics to explain (a) What values
          are stored in all variables whose states are changed. (b) What is the result computed by
          the expression. (c) What oval diagram illustrates parts a and b.
        Assume that each statement is executed just after the declaration <b>int a=3, b=5, c=8;</b>
<b><pre>   a = b++ + c;
   a = b + ++c;
   c = b+++c++;
   a+=b+=c+=1;
   a = b = c + 1;
   a = (b = c) + 1;
   System.out.println("" + ++b + b);
   System.out.println("" + b++ + b);</pre></b>

    <p>
    <li>Explain what is displayed on the console for the top and bottom block.
        Assume we have declared <b>int i; char c;</b> and that the ASCII equivalent of <b>'A'</b>
          is <b>65</b>.
    <pre><b>   {i = 'A';  System.out.println(i);}
   {c =  65;  System.out.println(c);}</b></pre>
    <p>

    <li>Show what is displayed in the console window after Java executes the following expression
          statements.
        Be very careful to show which word occurs on which lines.
        Remember that the escape character <b>\n</b> starts a new line.
    <pre><b>   System.out.print("When " + "in ");
   System.out.println( "the "
        + "course "
        + "of ");
   System.out.print("human\nevents ");
   System.out.print("it ");
   System.out.print("becomes ");
   System.out.println("necessary ");
   System.out.print("for one nation to sever...");</b></pre>
    
    <p>
    <li>Examine the following 6 blocks (all are are permutations of the same three
          statements).
        Classify each block as syntactically legal or illegal (hint: certain statement
          orderings are illegal because they violate a constraint on where a variable
          declared inside a block can be used).
        For those blocks that are legal, determine whether or not they swap of the values
          stored in <b>x</b> and <b>y</b>.<pre><b>        {int temp=x; x=y;        y=temp;}
        {int temp=x; y=temp;     x=y;}
        {x=y;        int temp=x; y=temp;}
        {x=y;        y=temp;     int temp=x;}
        {y=temp;     x=y;        int temp=x;}
        {y=temp;     int temp=x; x=y;}</b></pre>

    <p>
    <li>Examine each of the following statements; determine whether it is true or
          false (and be prepared to support your answer or show a counter example).
        <ul>
          <li>A block can be empty (contain no statements).
          <li>A block can be unitary (contain 1 statement).
          <li>The statements <b>x=y;</b> and <b>y=x;</b> have identical meanings.
          <li>If we declare <b>int x=5,y=8;</b> and Java executes the expression statement
                <b>x=y;</b> immediately followed by <b>y=3;</b> then
                both <b>x</b> and <b>y</b> now store <b>3</b>.
          <li>A single statement can change the state of more than one variable.
        </ul>

    <p>
    <li>The following block is rejected at compile time by the Java compiler.
        Write the error message that Java reports.
        Explain why it makes sense to recognize this problem and report the error.
<pre><b>  {
    int a;
    System.out.println("a = " + a);
  }</b></pre>

    <p>
    <li>Which of the following is easier to understand: the single statement or double statement?
        Verify that both perform the same computation.
<pre><b>  myPurse += stakes + 0*(myWins++);          myWins++;
                                             myPurse += stakes;</b></pre>
    <p>
    <li>Assume that we declare a
          <b>char grade;</b> and guarantee that it stores a letter corresponding
          to a UCI grade: <b>'A'</b>, <b>'B'</b>, <b>'C'</b>, <b>'D'</b>, or <b>'F'</b>.
        Write an <b>if</b> statement that computes the number of quality points for that grade
          and stores it in <b>int qp;</b>
        an A is worth 4, a B is worth 3, a C is worth 2, a D is worth 1, and an R is worth 0.
    <p>



   <li>Assume that we declare
         <b>int hours;</b>
       Write an <b>if</b> statement that computes the pay (in cents) due a worker according the following
         formulas: <b>625*Hours</b> if the hours worked is less than or equal to 40;
         <b>625*Hours + 725*(Hours-40)</b> if the hours worked is greather than 40.
       Store the result in <b>int centsPay;</b>
       Try a few examples under, at, and over 40 hours to verify your statement is correct.
   <p>

    <li>Assume that we declare 
           <b>int x, y; boolean isIt;</b>
         Write a trace table for the hand simulation of the following Java statements: one where
           <b>x</b> stores <b>3</b> and <b>y</b> stores <b>5</b>; and another where 
           <b>x</b> stores <b>5</b> and <b>y</b> stores <b>3</b>.
         State whether the results are the same or different in each case.<b><pre>   if (x < y )            if (x < y)
     isIt = true;          isIt = true;
   else                  isIt = false;
     isIt = false;</pre></b>
      Which statement side is equivalent to the expression statement <b>isIt = (x < y);</b>
    <p>

    <li>Assume that we declare 
          <b>int studentAnswer, correctAnswer, wrongCount;</b>
         Explain what is wrong with the following statement (there is a syntax error).<b><pre>   if (studentAnswer == correctAnswer)
   else
     wrongCount++;</pre></b>
      Explain how to fix this problem in a simple way.
    <p>

    <li>Modify the <b>cascaded if</b> for computing grades, so that <b>grade</b> stores <b>'?'</b> if
           <b>testScore</b> is outside the range <b>0</b> to <b>100</b> inclusive. 
     <p>

     <li>Write a trace table for the clock code, if the clock starts at 11:59pm (one minute before midnight).  
     <p>

     <li>Assume that we declare
           <b>double s, signum;</b>
         Write a cascaded <b>if</b> statement(s) that stores into <b>signum</b> the value <b>-1.</b> if <b>X</b> is less
            than <b>0.</b>; <b>0.</b> if <b>X</b> is equal to <b>0.</b>; <b>1.</b> if <b>X</b> is greater than
            <b>0.</b> 
     <p>

     <li>Assume that we declare
           <b>double min, x, max;</b>
         Write a cascaded <b>if</b> statement(s) that stores into <b>x</b> the value <b>min</b> if <b>x</b> is less
            than <b>min</b>; <b>max</b> if <b>x</b> is greater than <b>max</b>; nothing new otherwise.
     <p>

     <li>Assume that we declare
           <b>int x,y,z,min;</b>
         Write an <b>if</b> statement(s) that stores into <b>min</b> the minimum of the values stored in
            <b>x</b>, <b>y</b>, and <b>z</b>.
         Try to do this with the minimum amount of code.
     <p>

     <li>Re-examine the <b>cascade if</b> that computes a course grade.
         Which of the following statements are equivalent to it (do the same thing for all values
           stored in <b>testScore</b>)?<b><pre>    if (testScore >= 60)             if (testScore < 60)
      grade = 'D';                     grade = 'F';
    else if (testScore >= 70)        if (testScore < 70)
      grade = 'C';                     grade = 'D';
    else if (testScore >= 80)        if (testScore < 80)
      grade = 'B';                     grade = 'C';
    else if (testScore >= 90)        if (testScore < 90)
      grade = 'A';                     grade = 'B';
    else                             else
      grade = 'F';                     grade = 'A';</pre></b>
        What simple changes would correct any incorrect code?
     <p>

     <li>Suppose that we modify the clock code to call <b>emitBeeps</b> at the bottom of its block,
           and also change its argument to just <b>hour</b>.
         Will this code always work as before?
         If not, for what <b>hour</b> and <b>minute</b> combination(s) will it fail?<b><pre>
     if (minute != 59)
       minute++;
     else {
       minute = 0;
       if (hour != 23)
         hour++;
       else
         hour = 0;
       emitBeeps(hour);
     }</pre></b>
        Note that to be correct, the code must be correct for every <b>hour</b> and <b>minute</b>.
        There are 24x60 = 1,440 different possiblities; which ones are crucial to check?
     <p>

     <li>Suppose that we modify the clock code as follows.
         Will this code always work as before?
         If not, for what <b>hour</b> and <b>minute</b> will it fail?<b><pre>
     minute++;
     if (minute == 60} {
       minute = 0;
       hour++;
       emitBeeps(hour);
       if (hour == 24)
         hour = 0;
     }</pre></b><br>
        Note that to be correct, the code must be correct for every <b>hour</b> and <b>minute</b>.
        There are 24x60 = 1,440 different possiblities; which ones are crucial to check?
     <p>

     <li>Assume that we declare
           <b>int hour;</b>
         storing the values <b>0</b> through <b>23</b> as described above.
         Write an <b>if</b> statement(s) to display on the console the hour in a standard format:
           e.g., when <b>hour</b>
           stores <b>3</b> display <b>3am</b>; when <b>hour</b> stores 15 display <b>3pm</b>.
         When <b>hour</b> stores <b>0</b> display <b>12midnight</b> and when <b>hour</b> stores
           <b>12</b> display <b>12noon</b>.
         Try to do this with the simplest possible code.
     <p>

     <li>Write a standard trace table for the following code, when the user enter the value
           <b>3</b>; write a compact trace table for this value, and when the user enters <b>7</b>.     <b><pre>  int cycleCount = 0;
  int test = Prompt.forInt("Enter value to test");
  for (;;) {
    cycleCount++;

    //////////////
    if (test == 1)
      break;
    //////////////

    if (test%2 == 0)
      test = test/2;
    else
      test = 3*test + 1;
  }
  System.out.println("Finished in " + cycleCount + " cycles");</pre></b>
  <p>


  <li>The following two code fragments are identical to the original count down code,
           but the <b>if</b> appears in different locations inside the loop.
         Write a standard trace table for each showing its behavior and results.
         Can you change the <b>test</b> in the <b>if</b> to produce the original results?<b><pre>
   int countdown = 3;
   for (;;) {
     if (countdown == 0)
       break;
     System.out.println(countdown + "...");
     countdown--;
   }
   System.out.println("Blastoff");


   int countdown = 3;
   for (;;) {
     System.out.println(countdown + "...");
     countdown--;
     if (countdown == 0)
       break;
   }
   System.out.println("Blastoff");</pre></b>
  <p>

  <li>The following code fragment is identical to the original sentinel code,
         but the <b>if</b> appears in a different location inside the loop.
      Write a standard trace table for each showing its behavior and results.<b><pre>    int count = 0;
    int sum   = 0;
    int score;
    for (;;) {
      score = Prompt.forInt("Enter a Score (-1 to Terminate)");
      count++;
      sum += score;
      if (score == -1)
        break;
    }
    System.out.println("Average = " + (double)Sum/(double)Score);</pre></b>
  <p>

  <li>Rewrite the countdown loop more compactly, so that it uses a general
    <b>for</b> statement (without <b>if</b>/<b>break</b> in its body).
  <p>

  <li>Rewrite the sentinel loop twice, so that it uses a <b>while</b>
        loop and a <b>do</b> loop.
      It can be done, but what problem arises?
  <p>


  <li>The following code can be used to ensure that the user enters a positive value.
      Write a standard trace table for the following code, assuming the user enters the values
        <b>-5</b>, <b>-1</b>, and <b>8</b> respectively.<b><pre>
  int positive;
  for (;;) {
    positive = Prompt.forInt("Enter Positive Value");

    //////////////
    if (positive >= 1)
      break;
    //////////////

    System.out.println("Sorry, " + positive + " isn't postive!");
  }
  System.out.println("positive = " + positive);</pre></b>
  What changes would be necessary to ensure the user entered a positive and even value?
  <p>


  <li>Write a compact trace table for the following code, assuming the user enters the values
        <b>4</b>, <b>5</b>, <b>7</b>, <b>-3</b>, <b>-7</b>, <b>8</b>, <b>-8</b>, <b>11</b>,
        <b>15</b>, <b>-5</b>, <b>9</b>, and <b>-100</b> respectively.<b><pre>  int zcc = 0;
  int p = Prompt.forInt("Enter Value");
  for (;;) {
    int c;
    c = Prompt.forInt("Enter Value");

    //////////////
    if (c == -100)
      break;
    //////////////

    if (p < 0 != c < 0)
      zcc++;

    p = c;
  }
  System.out.println("Final zcc = " + zcc);</pre></b>
  <p>


  <li>Write a compact trace table for the following code, assuming the user enters the values
        <b>4</b>, <b>5</b>, <b>7</b>, <b>3</b>, <b>7</b>, <b>7</b>, <b>8</b>, <b>11</b>,
        <b>15</b>, <b>5</b>, <b>9</b>, and <b>-1</b> respectively.<b><pre>  int ll = 0;
  int cl = 0;
  int p = Prompt.forInt("Enter Value");
  for (;;) {
    if (cl > ll)
      ll = cl;
   
    int c = Prompt.forInt"Enter Value")

    //////////////
    if (c == -1)
      break;
    //////////////

    if (p < c)
      cl++;
    else
      cl = 0

    p = c;
  }
  System.out.println("Final ll = " + ll);</pre></b>
  <p>


  <li>Write code (see the previous two problems for inspiration) that determines whether all the
        values it prompts for (use <b>-1</b> as a sentinel) are in strictly increasing order:
        each value is greater than the one that precedes it.
      It should store its final answer in a <b>boolean</b> variable named <b>isIncreasing</b>.
      Write two compact trace tables for your code, assuming the user enters the values
        <b>4</b>, <b>5</b>, <b>3</b>, <b>5</b>, <b>2</b>, <b>4</b>, and <b>-1</b> the
        first time; and <b>4</b>, <b>5</b>, <b>7</b>, <b>7</b>, <b>-1</b> the second time.
  <p>


  <li>Write code that counts the number of strictly increasing pairs
        of values the user enters (use <b>-1</b> as a sentinel).
      It should store its final answer in an <b>int</b> variable named <b>increasingPairCount</b>.
      Write two compact trace tables for your code, assuming the user enters the values
        <b>4</b>, <b>5</b>, <b>3</b>, <b>3</b>, <b>7</b>, <b>6</b>, <b>8</b>, <b>9</b>, <b>2</b>,
        <b>5</b>, <b>4</b>, and <b>-1</b>.
      For this input, it finds 5 pairs: <b>4</b>:<b>5</b>, <b>3</b>:<b>7</b>, <b>6</b>:<b>8</b>,
        <b>8</b>:<b>9</b>, and <b>2</b>:<b>5</b>.
  <p>

  <li>Explain why the following <b>for</b> loop contains an error spotted by the Java compiler
      <b><pre>  for (int i=1; i<=10; i+1)
    System.out.println(i);</pre></b>
  <p>


  <li>Explain what the following <b>for</b> loop displays. Hint: it doesn't display all the
        even numbers from <b>1</b> to <b>10</b>.
      How could we write a <b>for</b> loop to accomplish this task?
      <b><pre>  for (int i=1; i<=10 && i%2==0; i++)
    System.out.println(i);</pre></b>
  <p>

  <li>Translate the following <b>for</b> loop into a <b>for(;;)</b> loop with a
        <b>break</b> in its body.
      <b><pre>  for (int i=5; i>=0; i--)
    System.out.println(i);</pre></b>
  <p>

  <li>Assume that we have declared <b>int Width, Height;</b> and stored values into these
        variables.
      Write a pair of nested <b>for</b> loops that print a rectangle of <b>'*'</b> that is
        <b>height</b> by <b>width</b>: e.g., if <b>height</b> was <b>5</b> and <b>width</b>
        was <b>20</b> it would display
      <b><pre>  ******************** 
  ******************** 
  ******************** 
  ******************** 
  ********************</pre></b>

  <li>What is syntactically wrong with the following <b>for</b> loop (be careful)?
      How can we rewrite it to satisfy the syntax but still do the same intended thing?
      <b><pre>    for (int i = 0, double d = 0.0; velocity>0 ; i++,d+=.01)</b></pre> 
<p>

    <li>Suppose that in the prompting code, we always want to set <b>answer</b> to <b>0</b>
          and terminate the loop if the user fails to enter a valid integer.
        Change the code to implement this requirement.
        Hint: this change requires just changing the block in the <i>catch-clause</i>.
    <p>

    <li>Explain whether or not the code below correctly reads all the
          integer values in a file and prints their sum.
        Note that this code contains a <b>for</b> loop in a <b>try-catch</b>
          statements with no <b>break</b> statement; the original code to
          solve this problem contained a <b>try-catch</b> (with a <b>break</b>
          statement) in a <b>for</b> loop.
  <pre><b>  int sum = 0;
  try {
    for (;;) {
      int aValue = inputFile.readInt();
      sum += aValue;
    }
  }
  catch (EndOfFileException eofe) {}
  System.out.println("Sum = " + sum);</b></pre>
  <p>

    <li>Suppose that in the file-reading code (from the lecture), we want to
      ignore any non-integer values encountered (but keep reading more
      values until there are no more in the file to read).
      How can we change the code to implement this requirement?
      Why might it be better not just to ignore it, but print an error
        message (and how can this be accomplished)?
      Finally, why can't we modify the code above to solve this problem too?
      Hint: look at how <i>catch-clause</i> appears in the EBNF
          <b>try-catch</b> statements. 
      Failing to read an <b>int</b> because some non<b>-int</b> value
          appears in the file will cause Java to throw the 
          <b>NumberFormatException</b>.

  </ol>
</td>
</tbody>
</table>

</body>
</html>

