<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Program 1</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Program 1</h1>
<h1>
Programming using the ICS-46 Template Library (ITL):<br>
Stack, Queue, Priority Queue, Set, and Map
</h1>
<p>
<h2>ICS-46: Data Structure Implementation and Analysis<br>
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
This programming assignment is designed to ensure that you know how to use
  combinations of ICL's templated classes to model and compactly write code
  that solves a variety of different programming problems.
The kind of abstract thinking that goes into modeling solutions to these
  programming problems with these data types (and iteration over them) is
  critical to your development as computer scientists.
<p>
There are three parts to this assignment.
In each you will be asked to write a program (<b>.cpp</b> file) that defines a
  few functions and has a <b>main</b> function, which ties these functions
  together to solve the problem.
<p>
You should download the 
  <a href="program1.zip">program1</a> project folder and use it to create an
  Eclipse project (needing only <b>courselib</b> not <b>googletest</b>).
You will create each program in this project, and submit each program
  separately in Checkmate.
The project folder contains boiler-plated files (including some <b>typedefs</b>
  that I found useful in my code: you may change their names) and contains all
  the data files you need to test/debug you program.
<b>Important: Only one of the <b>.cpp</b> files can be active at any time.</b>
In the download,only the <b>reachable.cpp</b> file is active; the other are
  inactive.
To make a progam inactive, select it (in the editor tab), use the <b>Ctrl/a</b>
  command to select all its lines, and then click <b>Source</b> at the top
  left of the menu and choose <b>Toggle Comment</b>: ever line will now appear
  in a comment; by using these same instructions, you can toggle back those
  lines not have comments.
<p>
<b>Instead, you can also use a existing/working project folder: remove (but
  save) all the files in its <b>src</b> folder and then put all the <b>.cpp</b>
  files from the downloaded project's <b>src</b> folder into the
  existing/working project's <b>src</b> folder.
Also put all the data files into the existing project folder, not in the
 <b>src</b> folder.</b>
<p>
You should work on this assignment in pairs, with someone in your lab section.
Try to find someone who lives near you, with similar programming skills,
  and work habits/schedule: e.g., talk about whether you prefer to work
  mornings, nights, or weekends; what kind of commitment you will make to submit
  program early.
If you believe that it is impossible for you to work with someone, because of
  some special reason(s), you should send me email stating them and asking for
  special permission to work alone (which I do grant, but not frequently).
<p>
<b>Only one student should submit all parts of the the assignment</b>, but both
  student's names should appear in the comments at the top of
  <b>each submitted .cpp</b> file.
It should look something like
<pre><b>
# Romeo Montague, Lab 1
# Juliet Capulet, Lab 1
# We certify that we worked cooperatively on this programming
#   assignment, according to the rules for pair programming</b></pre>
If you do not know what the terms <b>cooperatively</b> and/or
  <b>rules for pair programming</b> mean, please read about
  <a href="../../../common/handouts/pairprogramming.html">Pair Programming</a> 
  before starting this assignment.
Please turn in each program <b>as you finish it</b>, so that I can accurately
  assess the progress of the class as a whole during this assignment.
<p>
Print this document and carefully read it, marking any parts that contain
  important detailed information that you find (for review before you turn in
  the files).
You should familiarize yourselves with the <b>ics46goody.hpp</b> file in the
  <b>courselib/src</b> folder.
It contains functions useful in all these programs: <b>split</b> and <b>join</b>
  (like their counterparts in Python, they use <b>std::string</b> and 
  <b>vector&lt;std::string></b>, <b>prompt_string</b>, and <b>safe_open</b>.
<p>
<p>
This assignment has 3 parts: pairs should work on each part together, not split
  them up and do them separately.
Part 1 is worth 56 points; part 2 is worth 14 points; part 3 is worth 10 pts.
This skewing of points towards the simpler parts means students finishing the
  first part correctly will have a 70% average; those finishing the first 2 
  parts correctly will have an 87.5% average; but to get an A on this 
  assignment requires solving all parts correctly.
Remember I'm going to be running MOSS on the parts of this assignment.
<p>
The <b>cross_reference</b> program (downloadable by links from the
  <b>Lecture Schedule</b> or <b>Weekly Schedule</b>) show an exmple of the code
  you need to write: study and understand its code before attempting to start
  solving these problems.
Questions about <b>cross_reference</b>? Post them on a Message Board in the
  Forum.
<p>
Use the array implementations supplied in the ITL for all the data types.
<p>
I am supplying these number of lines not as a requirement, but as a ballpark
  estimate of the amount of code you should write.
</td>
</tbody>
</table>


<!-- Problem 1 -->

<a name="problem1">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #1: Reachability</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li>Write a program that prompts the user to enter the name of
       a file representing a graph.
<li>Read the information in the file, storing the graph in a map.

<li>Print the graph.
<li>Repeatedly prompt the user for a starting node in the graph, and compute and
      print all the nodes that are reachable from it by following edges in the
      graph: convert the algorithm below into C++/ITL code.
</ul>
<h3>Input and Output</h3>
Read a file of pairs of node names (representing edges) in a directed
  graph, building a <b>Map</b> whose key is a <b>std::string</b> source node
  and whose value is a <b>Set</b> of <b>std::string</b> destination nodes that
  are each reachable from the source node key.
Although the supplied input files use 1-letter names, your code should work
  for any strings: use the <b>split</b> function in <b>ics46goody.hpp</b>.
<p>
Two nodes appear on each line: first the source node, then the destination
  node, with these node names separated by one semicolon character.
For example, the input file <b>graph1.txt</b> contains the following
  lines (which could appear in this order, or any other):
<b><pre>  c;f
  b;d
  a;c
  c;e
  d;g
  a;b
  e;d
  f;g
  f;d</pre></b>
which represent the graph
<p>
<image src="images/graph.gif">
<p>
Print the graph, one source node per line (the source nodes are printed
  alphabetically) followed by the set of all the destination nodes that the
  source can immediately reach.
The graph above would print as
<b><pre>  Graph: source -> {destination} edges
    a -> set[c,b]
    b -> set[d]
    c -> set[f,e]
    d -> set[g]
    e -> set[d]
    f -> set[g,d]</pre></b>
<p>
Note that the source nodes are <b>sorted</b> alphabetically, but the <b>Set</b>
   of desintation nodes does <b>not have to be sorted</b>:
  in fact it makes no sense to talk about sorted <b>Sets</b>; we could talk
  about a sorted <b>Priority Queue</b> whose contents came from a <b>Set</b>.
Note that because node <b>g</b> is not a source node (it is only a
  destination node), it does not appear first on any line (and appears only
  in the <b>Sets</b> for source nodes <b>d</b> and <b>f</b>.
<p>
Note that there are multiple data files for this program: <b>graph1.txt</b>,
  <b>graph2.txt</b> and <b>graph3.txt</b>; test/debug your program on 
  the first file; when you are done, test it on the last two.
Draw the graph represented by each for to ensure that your code correctly
  prints it and computes the nodes reachable from any source node (which you
  can do by eyeballing the graphs: they are small).
<p>
Repeatedly prompt the user for a starting node in the graph (until <b>quit</b>
  is entered) and compute and print all the nodes that are reachable from it by
  following edges in the graph.
Reject any node not present ask keys in the graph.
An example interaction (processing the graph above) might be
<b><pre>  Enter starting node: e
  Reachable from e = set[e,d,g]

  Enter starting node: x
    x is not a key in the graph

  Enter starting node: a
  Reachable from a = set[a,c,b,f,e,d,g]

  Enter starting node: quit</pre></b>
<h3>Functions and Program</h3>
<ul>
<li><b>read_graph</b> has an open (file) parameter; it returns the <b>Map</b>
     representing the graph
    (mine is 12 lines of code).
<p>
<li><b>print_graph</b> has a <b>Map</b> parameter (representing the graph); it
    returns nothing, but it prints the graph in the appropriate form
     (mine is 8 lines of code).
<p>
<li><b>reachable</b> has a <b>Map</b> parameter (representing the graph) and
    a <b>std::string</b> start node in the graph (technically a key in the
    <b>Map</b>; it returns a <b>Set</b> of all the nodes reachable from it by
    following edges in the graph
   (mine is 15 lines).
<p>
<li>Write a program at the bottom of this module that calls these functions
     to solve the problem
     (mine is 22 lines).
    To simplify the interaction, you may prompt for the file name and specify
      a default value (<b>graph1.txt</b>): see my <b>prompt_string</b> function
     in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.
<p>
Here is the basic algorithm for computing reachability; it is simple to explain
  and not (very) complicated to implement.
But, you have to understand these instructions and carefully translate them into
  C++/ITL code.
You should hand-simulate this algorithm using the graph above, and verify that
  it produces the results you expect before coding it.
You might be tempted to use recursion, but please don't: unless recursion is
  done very carefully, it will run forever on graphs with cycles: one of the
  input files is a graph with cycles.
<ol>
<li>To compute all the reachable nodes in a graph, create a <b>Set</b>
   (initially empty) of reached nodes and a <b>Queue</b> (initially containing
   the  parameter start node) of nodes that we are going to explore (to find
   nodes they can reach).
<p>
<li>While the <b>exploring queue</b> still has nodes, remove the first one
    and put it into the <b>reached set</b>; if it is a key in the graph (not all
    nodes are) then for all its destination nodes that are not already in the
   <b>reached set</b>, put them in the <b>exploring queue</b>.
<p>
<li>When the <b>exploring queue</b> becomes empty (can you argue that this
      always will happen -there is no infinite looping), return the
      <b>reached set</b>.
</ol>
<p>
Print the set containing all these node labels.
When debugging this algorithm, print the <b>Set</b> and <b>Queue</b> after every
  interesting change, or use the debugger to observe these changes.
</ul>
<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one (sets will match if they have the same
  contents, independent of their order).
You should also check that it works for other starting nodes, and
  a variety of starting nodes in the other graphs.

<b><pre>  Enter file with graph: <i>graph1.txt</i>

  Graph: source -> {destination} edges
    a -> set[c,b]
    b -> set[d]
    c -> set[f,e]
    d -> set[g]
    e -> set[d]
    f -> set[g,d]

  Enter starting node: e
  Reachable from e = set[e,d,g]

  Enter starting node: x
    x is not a key in the graph

  Enter starting node: a
  Reachable from a = set[a,c,b,f,e,d,g]

  Enter starting node: quit</pre></b>
</td>
</tbody>
</table>


<!-- Problem #2 -->

<a name="problem6">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #2: Instant Runoff Voting</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li> Write a program that prompts the user to enter the name of
       a file representing the preference of a sequence of voters.
<li>Read the information in the file, storing it in a <b>Map</b>.
<li>Print the voter preference.
<li>Repeatedly display the vote count for ballots (sorted both by candidate
      and numerically), eliminating from the election the candidate receiving
      the fewest votes, until one candidate (the winner) or no candidates
      (a tie) remain.
</ul>
This form of election is known as <b>instant runoff voting</b>.
Every voter submits a ballot that ranks all the candidates the election, from
  most favorite candidate to least favorite (we will use a <b>Queue</b>
  for this purpose</b>: earlier in the <b>Queue</b> means more favored).
During the first ballot, votes are counted for each of the candidates according
  to the rankings of the voters.
Then the candidate(s) with the fewest number of votes are removed from the
  election: if more than one candidate receives the least number of votes, they
  all are removed from the election.
During the second ballot, votes are tallied for the <b>remaining candidates</b>
  (there are at least 1 fewer candidates); if a voter's first ranked candidate
  is not still in the  election, then his/her second ranked candidate should
  receive the vote; but if his/her second ranked candidate has been removed
  from the election, then his/her third ranked candidate should receive the
  vote ...).
This ballot process continues until either 1 candidate remains, or 0 candidates
  remain (meaning that all the remaining candidates tallied the same number
  of votes).
<h3>Input and Output</h3>
Read a file of voters and their ranking of the candidates, separated
  by semicolons, building a <b>Map</b> whose key is each voter and whose
  value is a <b>Queue</b> of candidates ranked by that voter (they appear in the
  file in order, from most favorite to least favorite).
<p>

For example, the input file <b>votepref1.txt</b> contains the following
  lines (which could appear in this order, or any other):
<b><pre>  A;X;Y;Z
  B;Y;Z;X
  C;Y;Z;X
  D;Z;Y;X
  E;Z;Y;X</pre></b>
The first line means, voter <b>A</b> ranks candidate <b>X</b> first,
  candidate <b>Y</b> second, and candidate <b>Z</b> third.
The second line means, voter <b>B</b> ranks candidate <b>Y</b> first,
  candidate <b>Z</b> second, and candidate <b>X</b> third.
Each line will have a unique voter and a permutation of all the 
  candidates running.
<p>
Print all the associations in this <b>Map</b>, one per line (the voters are
  printed alphabetically) using the following form.
Each line contains the voter and his/her complete ranking of the candidates.
For example, the file above would produce:
<b><pre>  Voter Preferences
    A -> queue[X,Y,Z]:rear
    B -> queue[Y,Z,X]:rear
    C -> queue[Y,Z,X]:rear
    D -> queue[Z,Y,X]:rear
    E -> queue[Z,Y,X]:rear</pre></b>
<p>
Note that the voter names are <b>sorted</b> alphabetically, but the <b>Queue</b>
  of preferences appears in the same order they appeared in the file.
There are multiple data files for this program: <b>votepref1.txt</b>, 
  <b>votepref2.txt</b> and <b>votepref3.txt</b>; test/debug your program on the
  first file; when you are done, test it on the rest.
<p>
Start with all the candidates.
Evaluate the ballot to determine how many votes each candidate received.
Print this vote count two ways: sorted alphabetically and sorted numerically
  (in decreasing order).
Remove the candidate(s) receiving the fewest votes, and repeat this process
  until only one or no candidates remain.
Finally, print the outcome of the election: a single candidate winner or a tie.
An example interaction (processing the preferences above) might be
<b><pre>  Vote count on ballot #1 with candidates alphabetically: still in election = set[X,Y,Z]
    X -> 1
    Y -> 2
    Z -> 2
  
  Vote count on ballot #1 with candidates numerically: still in election = set[X,Y,Z]
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2 with candidates alphabetically: still in election = set[Y,Z]
    Y -> 3
    Z -> 2

  Vote count on ballot #2 with candidates numerically: still in election = set[Y,Z]
    Y -> 3
    Z -> 2

Winner is Y</pre></b>
The first ballot consisted of all three candidates, <b>X</b>, <b>Y</b>, 
  and <b>Z</b>.
For this ballot, the votes were counted and printed; candidate <b>X</b>
  received the fewest number of votes so is eliminated from the next ballot.
The second ballot consisted of two candidates, <b>Y</b> and <b>Z</b>.
For this ballot, the votes were counted and printed; candidate <b>Z</b>
  received the fewest number of votes so is eliminated from the next ballot.
There is only one candidate remaining so <b>Y</b> is declared the winner.
An alternative outcome might be
<b>No winner: election is a tie among candidates remaining on the last ballot</b>
<h3>Functions and Program</h3>
<ul>
<li><b>read_voter_preferences</b> has an open (file) parameter; it returns the
       <b>Map</b> representing each voter and his/her preferences
      (mine is 6 lines).
<p>
<li><b>print_voter_preferences</b> has a <b>std::string</b> title and a
         <b>Map</b>of voter preferences as parameters and returns nothing;
         it prints the title followed by the <b>Map</b> whose keys are in
         alphabetical order
       (mine is 9 lines of code).
<p>
<li><b>print_tally</b> has a <b>std::string</b> title, a <b>Map</b> of
         candidates and their number of votes, and a
         function pointer as parameters and returns nothing; it
         prints the title followed by the <b>Map</b> in the appropriate order
         order (specified  by the function pointer)
       (mine is 9 lines of code).
<p>
<li><b>evaluate_ballot</b> has a <b>Map</b> of voter preferences and a
         <b>Set</b> of the remaining candidates as parameters; it returns
         a <b>Map</b> whose keys are these candidates and whose values are the
         number of votes they received on this ballot, based on the
         description of <b>instant runnoff voting</b>
       Remember to count only one vote per voter, for his/her highest ranked
         candidate stil in the election
      (mine is 12 lines of code).
<p>
<li><b>remaining_candidates</b> has a <b>Map</b> as a parameter whose keys are
          candidates and whose values are the number of votes they received and
          returns a set containing all those candidates remaining in the
          election (the one(s) receiving the fewest number of votes are absent).
       Note that if all the candidates receive the same number of votes, then
         this function returns an empty <b>Set</b>
       (mine is 12 lines).
<li>Write a program at the bottom of this module the calls these functions
     to solve the problem
     (mine is 30 lines of code).
   To simplify the interaction, you may prompt for the file name and specify
      a default value (<b>votepref1.txt</b>): see my <b>prompt_string</b>
      function in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.
</ul>
<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<pre><b>  Enter file with voter preferences: <i>votepref1.txt</i>

  Voter Preferences
    A -> queue[X,Y,Z]:rear
    B -> queue[Y,Z,X]:rear
    C -> queue[Y,Z,X]:rear
    D -> queue[Z,Y,X]:rear
    E -> queue[Z,Y,X]:rear

  Vote count on ballot #1 with candidates alphabetically: still in election = set[X,Y,Z]
    X -> 1
    Y -> 2
    Z -> 2
  
  Vote count on ballot #1 with candidates numerically: still in election = set[X,Y,Z]
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2 with candidates alphabetically: still in election = set[Y,Z]
    Y -> 3
    Z -> 2

  Vote count on ballot #2 with candidates numerically: still in election = set[Y,Z]
    Y -> 3
    Z -> 2

  Winner is Y</pre></b>
<p>
You can also try processing the <b>votepref2.txt</b> file (which leads to
  a <b>No winner</b> result) and <b>votepref3.text</b>.
</td>
</tbody>
</table>



<!-- Problem 3 -->

<a name="problem3">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #3: Finite Automata</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
<ul>
<li>Write a program that prompts the user to enter the name of
       a file representing a finite automaton: indicating its <b>states</b> and
       input-&gt;state <b>transitions</b>.
<li>Read the information in the file, storing it in a <b>Map</b>.
<li>Print the finite automaton.
<li>Prompt the user for to enter the name of a file storing the start-state
      and inputs to process (each line in the file contains this combination).
<li>Repeatedly process these lines computing the results of the finite
      automaton on each input, and then display the results.
</ul>
A <b>finite  automaton</b> (FA) is an machine that is sometimes called
  Deterministic Finite Automaton (DFA).
An FA is described by its <b>states</b> and its <b>transitions</b>:
  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what
  <b>state</b> in the FA that input leads to.
We can illustrate a FA as a graph with labelled edges (see below).
<p>

<h3>Input and Output</h3>
Read a file that describes a FA: each line contains a state and an
  arbitrary number of input-&gt;state <b>transitions</b>.
Build a <b>Map</b> such that each key is a <b>std::string</b> state and whose
   values is another <b>Map</b> specifying of the transitions from that state:
   this second <b>Map</b> has keys that are <b>std::string</b> inputs and 
   values are <b>std::string</b> states.
The first token on each line is the <b>std::string</b> state and the remaining tokens
  (always coming in pairs) are <b>std::string</b> inputs and states.
All tokens are separated by one semicolon character.
<p>

For example, the input file <b>faparity.txt</b> contains the following lines
  (which could appear in this order, or any other):
<b><pre>  even;0;even;1;odd
  odd;0;odd;1;even</pre></b>
Here is a picture of the <b>parity</b> FA.
It graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)
  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)
  that always lead back to one of these two states.
<p>

<img src="images/parity.jpg"></img>
<p>

Here, the state <b>even</b> (meaning it has seen an even number of <b>1</b>
  inputs so far) is a key in the main <b>Map</b>.
It's value is a <b>Map</b> with two key/value pairs <b>0</b>/<b>even</b>
  and <b>1</b>/<b>odd</b>.
It means that in the <b>even</b> state, if the input is a <b>0</b> the
  FA stays in the <b>even</b> state; if the input is a <b>1</b> the
  FA goes to the <b>odd</b> state.
And similarly (the next line) means that for the <b>odd</b> state, if the input
  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a
  <b>1</b> the FA goes back to the <b>even</b> state.
So, seeing an input of <b>0</b> keeps the FA in the same state;
  seeing an input of <b>1</b> flips the FA into the other state.
<p>

Print the finite automaton, one state (and its transitions) per line;
  the states are printed alphabetically.
<p>
For example, the file above would produce:
<b><pre>  Finite Automaton Description
    even transitions: map[0->even,1->odd]
    odd transitions: map[0->odd,1->even]</pre></b>
<p>
Note that there are multiple data files for this program: <b>faparity.txt</b>
  and <b>fadivisibleby3.txt</b>; test/debug your program on 
  the first file; when you are done, test it on the last file.
Draw the FA represented by each for to ensure that your code correctly
  prints and computes with it.
<p>
Repeatedly process lines from a second input file, computing the results of the
  finite automaton for a start-state and its inputs; then print out all the
  results in a special form.
Each line in the file contains a start-state followed by a sequence of inputs.
The start-state will be a state in the FA (is a key in the outer <b>Map</b>)
  the inputs may specify legal or illegal transitions (may or may not be keys
  in some inner <b>Map</b>).
<p>
For example, the input file <b>fainputparity.txt</b> contains the following
  three lines:
<b><pre>  even;1;0;1;1;0;1
  odd;1;0;1;1;0;1
  even;1;0;1;1;0;x</pre></b>
The first line means, the start-state is <b>even</b> and the
  inputs are <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.
<p>
The result of processing each line is to print the start-state, and then each
  input and the new state it transitions to, and finally print the stop-state.
For the <b>parity</b> FA and the first line in this file, it should print
<b><pre>Start state = even
  input = 1; new state = odd
  input = 0; new state = odd
  input = 1; new state = even
  input = 1; new state = odd
  input = 0; new state = odd
  input = 1; new state = even
Stop state = even</pre></b>
<p>

<h3>Functions and Program</h3>
<ul>
<li><b>read_fa</b> has an open (file) parameter; it returns the <b>Map</b>
     representing the finite automaton
     (mine is 16 lines of code).
<p>
<li><b>print_fa</b> has a <b>Map</b> parameter (representing the fa); it
    returns nothing,  but it prints the fa in the appropriate form
     (mine is 8 lines of code).
<p>
<li><b>process</b> has a <b>Map</b> parameter (representing the fa),
    a <b>std::string</b> parameter (representing the start-state), and a
    <b>Queue</b> parameter (representing a <b>Queue</b> of <b>std::string</b>
    inputs); it returns a <b>Queue</b> that contains <b>pair</b>s of
    <b>std::string</b> that show the input and resulting state after each
    transition (the first value on the <b>Queue</b> has an input that is an
    empty string and the start state.
    For the example shown above, <b>process</b> returns the following
    <b>Queue</b>.
<b><pre>queue[pair[,even],pair[1,odd],pair[0,odd],pair[1,even],pair[1,odd],pair[0,odd],pair[1,even]]:rear</pre></b>
    Finally, if an input is illegal (is not the key in some transition for the
    current state), say
    <b>'x'</b>, then <b>process</b> should terminate with the last
    <b>pair</b> in the <b>Queue</b> indicating a problem: <b>('x', "error")</b>
   (mine is 13 lines of code).
<p>
<li><b>interpret</b> has a <b>Queue</b> parameter (the result produced by
    <b>process</b>); it returns nothing, but it prints the results of processing
    a fa on an input.
    See how it prints the <b>Queue</b> shown above in the output further above.
    Also see the <b>Sample Interaction</b> below to see how it prints
    <i>input errors</i> (in the last example)
   (mine is 13 lines of code).
<p>
<li>Write a program at the bottom of this module that calls these functions
        to solve the problem.
      Note that the program loops over the lines in the second file
       (mine is 23 lines of code).
    To simplify the interaction, you may prompt for the file name and specify
      a default value (<b>faparity.txt</b> and <b>fainputparity.txt</b>): see
      my <b>prompt_string</b> function in <b>ics46goody.hpp</b> in the
      <b>courselib/src</b> folder.
</ul>
<p>

<h3>Sample Interaction</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<b><pre>  Enter file with finite automaton: faparity.txt

  Finite Automaton
    even transitions: map[0->even,1->odd]
    odd transitions: map[0->odd,1->even]

  Enter file with start-state and input: fainputparity.txt
  
  Starting new simulation
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
  Stop state = even
  
  Starting new simulation
  Start state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
  Stop state = odd
  
  Starting new simulation
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = x; illegal input: terminated
  Stop state = None</b></pre>
<p>
You can also try the <b>fadivisibleby3.txt</b> finite automaton file, which
  determines whether an integer (sequence of digits) is divisible by 3: it is
  if the  finite automaton stops in state <b>rem0</b>.
Its input files are <b>fainput1divisibleby3.txt</b> (which represents the 
  number <b>12,435,711</b>, which is divisible by 3)
  and <b>fainput2divisibleby3.txt</b> (which represents the number <b>823</b>,
  which is not divisible by 3).
</td>
</tbody>
</table>


</tbody>
</table>
</html>

