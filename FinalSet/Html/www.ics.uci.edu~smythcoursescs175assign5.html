<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/4.76 [en] (WinNT; U) [Netscape]">
  <title>ICS 175: Project in Artificial Intelligence</title>
</head>
<body alink="#ff3300" bgcolor="#f3f9fe" link="#cc0000" text="#000000"
 vlink="#330099">
<center>
<h1>Assignment 5:&nbsp; CS 175: Project in Artificial Intelligence</h1>
</center>
<center>
<h2>Due at 9:30 am Tuesday November 6th<br>
</h2>
</center>
<hr>
<h3><big><font size="+0"><big>General Instructions for Assignment 5</big></font></big></h3>
<p><big><font size="-1"><big>This assignment consists of 2 parts. You should review the slides (from the Web page) on filtering, edge-detection and template-matching before working on this assignment.</big></font></big></p>
<p><big><font size="-1"><big>MATLAB code and
  data files that
  you can use for this assignment can be found <a
 href="assignment5_code.zip">here</a> in a Zip file including&nbsp; the
  templates t1 and t2 for the eye and nose templates as shown
  in class, in templates.mat. For evaluation you will use the straight
  images
  in i2straight.mat (also includes in the Zip file) each of size 60x64 pixels.</big></font></big></p>
<ul>
  <big> </big><li><big> <font size="-1"><big>Part 1: implement a
function to calculate edge
images and
display the results</big></font></big></li>
  <big> </big><li><big> <font size="-1"><big>Part 2: implement a
function to find a best-match
for a template
and display the results</big></font></big></li>
  <big></big>
</ul>
<big><font size="-1"><big>Before you begin any coding of MATLAB
functions, you
should
verify that you can
run filterdemo.m and edgedemo.m (contained in the Zip file above). These are two simple demonstration
scripts
that illustrate the use of some of the filters and edge detectors that
we saw in class. These demo scripts should work on your PC, provided
you
have all of the various functions such as f2special.m and edge.m
included
in your MATLAB path.</big></font></big>
<h4><big>Part 1: Edge Detection</big></h4>
<big><font size="-1"><big>As discussed in class, MATLAB
allows you
to
perform edge detection quite easily. Write a function that takes as
input
a single image and the sigma parameter for the LoG edge Detector, then
calculates the edge images (the thresholded binary images, or "edge
maps")
for each of&nbsp; Sobel, Roberts, and LoG edge detectors, and returns
the
edge images for each of these 3 as E1,E2,E3. Also, the function&nbsp;
should
take an&nbsp; optional argument "plotflag" which when set to 1 causes
the
function to display a 2 x 2 mosaic of images, where the top left image
is the original gray-scale image, the top right image is the Sobel edge
map, the bottom left image is the Roberts edge map,and the bottom right
one is the LoG edge map. Use subplot (2,2,i) to create a 2 x 2 mosaic,
where i will refer to which of the 4 locations in the 2 x 2 mosaic you
are plotting in. Have your code put a title
above each image (e.g.,"Sobel edge map").</big></font></big>
<p><big><font size="-1"><big>Here is the function header:</big></font>
</big></p>
<p><big><font size="-1"><big>&nbsp;function [E1, E2, E3] =
edgemaps(img, sigma,
plotflag)</big></font>
<br>
<font size="-1"><big>% [E1, E2, E3] = edgemaps(img, sigma, plotflag)</big></font>
<br>
<font size="-1"><big>%</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A. Student, CS 175</big></font><br>
<font size="-1"><big>%</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp; Inputs:</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp; img: a single pixel intensity image:
matrix of doubles of size m x n</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp; sigma: a positive scalar, to be used
as
the "scale parameter" for the LoG edge detector</big></font>
<br>
<font size="-1"><big>%&nbsp; plotflag:&nbsp; if 1 a plot is generated,
no
plot otherwise</big></font>
<br>
<font size="-1"><big>%</big></font>
<br>
<font size="-1"><big>%&nbsp; Outputs:</big></font>
<br>
<font size="-1"><big>%&nbsp; E1, E2, E3: binary images (pixel matrices)
from
Sobel, Roberts, and LoG edge detectors respectively</big></font>
</big></p>
<ul>
  <big> <font size="-1"><big>&nbsp;&nbsp;&nbsp; ----------------
your&nbsp; code
goes
here ------------------</big></font>
  </big>
</ul>
<h4><br>
</h4>
<h4><big>Part 2: Template Matching</big></h4>
<big><font size="-1"><big>We discussed the technique of template
matching in
class in Lecture 10.
Write a function that takes as input a single image and a template, and
returns both the location (in pixel coordinates, i, j) of the best
match
as well as the "distance image".&nbsp; The distance image is defined as
an image of pixels, where pixel (i,j) contains the calculated distance
between the template and the original image, when centered at pixel
(i,j)
in the original image. Use the square of the Euclidean distance for
"distance",
i.e., the usual Euclidean distance calculation but without the square
root.
Your function should&nbsp; also take a third argument "plotflag" which,
when set to 1, plots a 2 x 2 mosaic, where</big></font></big>
<ul>
  <big> </big><li><big> <font size="-1"><big>upper left: original
image of size m x n</big></font></big></li>
  <big> </big>
  <li><big> <font size="-1"><big>upper right: the
template (embedded in the center
of a black
image of size m x n, so that it is plotted on the same spatial pixel scale as
the
other images)</big></font></big></li>
  <big> </big>
  <li><big> <font size="-1"><big>lower left: the
"distanceimage",i.e.,a pixel image
of distances
between the template and the original image, where brighter values correspond to smaller distances.</big></font></big></li>
  <big> </big>
  <li><big> <font size="-1"><big>lower right: the
original image again, but where a
box of
black pixels of size tx x ty (the&nbsp; template size) have been
inserted,centered
at the pixel location of the best match (as shown in slides in class).</big></font></big></li>
  <big></big>
</ul>
<p><big><br>
<font size="-1"><big>Here is the function header:</big></font>
</big></p>
<p><big><font size="-1"><big>&nbsp;function [location, distance_image]
=
template_match(img,
template, plotflag)</big></font>
<br>
<font size="-1"><big>%&nbsp; [location, distance_image] =
template_match(img,
template, plotflag)</big></font>
<br>
<font size="-1"><big>%</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A. Student,&nbsp; CS 175</big></font><br>
<font size="-1"><big>%</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp; Inputs:</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp;&nbsp; img: a single pixel
intensity
image: matrix of doubles of size m x n</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp;&nbsp; template: a small
template
image, a matrix of doubles of size tx x ty</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp;&nbsp; plotflag:&nbsp; if 1 a
plot
of the results is generated, no plot otherwise</big></font>
<br>
<font size="-1"><big>%</big></font>
<br>
<font size="-1"><big>%&nbsp; Outputs:</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp; location: a 1 x 2 vector
containing
the pixel location (x and y) of the best (minimum distance) match</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the
template
in the image</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp; distance image: pixel image of
distances
between the template and the original image, in the</big></font>
<br>
<font size="-1"><big>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; form of a
matrix
of distances of&nbsp; size n x m</big></font>
</big></p>
<ul>
  <big> <font size="-1"><big>&nbsp;&nbsp;&nbsp; ----------------
your&nbsp; code
goes
here ------------------<br>
  <br>
  </big></font><br>
  </big>
</ul>
<p>Some questions that may come up about distance_images:<br>
<small>1. </small>What is "distance_image"?&nbsp; it is an image of
distances: if the original<span style="font-family: monospace;"> </span>image
is of size m x n, create an image of zeros of size m x n and<span
 style="font-family: monospace;"> </span>fill it up with distances:
the distance at pixel(i,j) is the distance between a template centered
at (i,j) and the local<span style="font-family: monospace;"> </span>pixels
around (i,j) in the original image.</p>
<p>2. what if the template is an "even" size? e.g., 10 x 10,<span
 style="font-family: monospace;"> </span>so that there is no obvious
"center" pixel: in that case you can<span
 style="font-family: monospace;"> </span>arbitrarily define one of the
pixels close to the<span style="font-family: monospace;"> </span>center
(in this case one of (5,5), (5,6), (6,5), or (6,6))<span
 style="font-family: monospace;"> </span>as the center pixel for the
template, i.e., you would<span style="font-family: monospace;"> </span>"center"
pixel (5,5) (for example) in the template at pixel (i,j) in the<span
 style="font-family: monospace;"> </span>original image, to calculate
the distance at (i,j). <br>
</p>
<p>3. what about the pixels at the edge? you should not<span
 style="font-family: monospace;"> </span>calculate a distance for any
pixels (i,j) that fall into<span style="font-family: monospace;"></span>
the following category: if you put the template at pixel location (i,j)
in the image, and location (i,j) is near the outer edge of the image,
some of the pixels in the template will lie outside the<span
 style="font-family: monospace;"> </span>range of the pixels in the
original image, e.g., putting<span style="font-family: monospace;"> </span>a
10 x 10 template at pixel location (2,3). So instead of calculating a
distance
here, you can just put a 0 value in the distance image. If you follow<span
 style="font-family: monospace;"> </span>this rule, you will get a
"band" of pixels of value 0 around<span style="font-family: monospace;">
</span>the edge of the image, where the width of the band is<span
 style="font-family: monospace;"> </span>roughly 1/2 the size of the
template. Naturally you<span style="font-family: monospace;"> </span>should
not include these "band pixels" when you are searching for the pixel
with minimum distance (for<span style="font-family: monospace;"> </span>locating
where to display the template matching result) - so you will need to
keep track of where the valid distances are (e.g., a
binary mask image indicating which (i,j) pixels are calculated
distances, and which (i,j) pixels (near the edge) were set to 0.<big>&nbsp;
<br>
</big></p>
<p>4. in the examples I showed in the lecture slides, for the distance
image plot, I mapped small distances to bright pixel values and large
distances to dark pixel values. To do this, after you calculate your
distance matrix, you can call your plotting function (such as
dispimg.m, but with the "figure" command removed so that it will work
with the subplot.m function) as dispimg(-distance). This will have the
effect of reversing the distances and will result in the desired effect
of having smaller distances mapped to brighter values.<br>
</p>
<p><big><br>
</big></p>
<hr>
<h3><big><font size="+0"><big>What to Turn In</big></font></big></h3>
<ul>
  <li><big> <font size="-1"><big>Turn in your MATLAB code for all of
the functions
above,
using the exact names and argument lists as specified above. Also
include
in your directory any other functions you wrote that are not included
in
the standard MATLAB path (including any functions from previous
assignments
that you use). You can use, edit, or modify any code that you wrote for
previous assignments, and any code that was given to you as part of
this class (e.g., in CS 175 slides, email announcements, or
assignments).<br>
    </big></font></big></li>
  <li><big> <font size="-1"><big>Write a single report in Word, which
clearly
contains all
of the following. In your report <b>clearly</b> mark your name at the
top
of the report.</big></font></big></li>
  <ul>
    <big> </big><li><big> <font size="-1"><big>Plots of the mosaic
of&nbsp; 2 x 2 edge&nbsp;
images from
the code in Part 1, for individual 5, image 4 and for&nbsp; individual
15, image 1 (from
i2straight.mat).&nbsp; Use&nbsp; a value of 3 for sigma for the LoG
edge detector <br>
      </big></font></big></li>
    <big> </big><li><big> <font size="-1"><big>Write some brief
comments on your interpretation
of the results.</big></font></big></li>
    <big> </big><li><big> <font size="-1"><big>Plots of the mosaic
of&nbsp; 2 x 2 template&nbsp;
images
from the code in Part 2, for (a) individual 2, image 1, (b) individual
14, image 2, (c)
individual
16,&nbsp; image 1, and (d) individual 7, image 1 (from
i2straight.mat),using&nbsp; both templates t1
and
t2 (so 8 mosaics in total here, 4 per individual).</big></font></big></li>
    <big> </big><li><big> <font size="-1"><big>Write some brief
comments on your interpretation
of the results.</big></font></big></li>
    <big> </big>
  </ul>
  <li><big> <font size="-1"><big>Put all your .m files and your Word
file in the EEE
"drop box", in the Assignment 5 directory.</big></font></big></li>
  <li><font size="-1"><big>Hand in a hardcopy of your assignment (your
Word document plus the MATLAB code for edgemaps.m and template_match.m
plus any new functions that you wrote) in class on Tuesday - make sure
your name is on the front page.</big><br>
    </font></li>
</ul>
</body>
</html>

